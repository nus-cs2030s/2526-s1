layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga Sidi Prabawa</p></div>

---

name: Introduction
class: bottom, titles

# CS2030S
## Programming Methodology II
### L12: Putting Things Together

---
name: Overview
class: sections

.topsub.subsections[
### Priority
]
.botbody.oldsections[
#### Problem Solving

.col100[
.card.bg-b[
##### CS1101/S: Correctness
.content.tight[
**Highest Priority:** Write Correct Program.
]
]
]

.vs10[]

.col50[
.card.bg-g[
##### CS2030/S: Maintainability
.content.tight[
Maintainable Program
- More human-friendly
- Fewer code duplication
- Fewer crashes
]
]
]
.col50[
.card.bg-r[
##### CS2040/S: Efficiency
.content.tight[
Efficient Program
- Use better algorithm
- Use better data structure
- Use better language
]
]
]
]

---

.topsub.subsections[
### Priority
]
.botbody.oldsections[
#### Problem Solving

.col100[
.card.bg-b.op25[
##### CS1101/S: Correctness
.content.tight[
**Highest Priority:** Write Correct Program.
]
]
]


.vs10[]

.col50.op25[
.card.bg-g[
##### CS2030/S: Maintainability
.content.tight[
Maintainable Program
- More human-friendly
- Fewer code duplication
- Fewer crashes
]
]
]
.col50.op25[
.card.bg-r[
##### CS2040/S: Efficiency
.content.tight[
Efficient Program
- Use better algorithm
- Use better data structure
- Use better language
]
]
]

.vs10[]

.col100[
.img55.center[![Design](img/12-Design.jpg)]
]
]

---
name: Object
class: sections

.topsub.subsections[
### Abstraction
#### Principle
]
.botbody.oldsections[
#### Principle

.col100[
.card.bg-g[
##### The Abstraction Principle
.content.tight[
_"Each significant piece of functionality in a program should be **implemented in just one place** in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to **combine them into one by abstracting** out the varying parts."_

.right[Benjamin C. Pierce]
]
]
]

.vs10[]

.col50[
.card.bg-b[
##### Composition
.content.tight[
**Composition** captures the **has a** relationship. It allows building more complex objects by separating the responsibilities.
]
]
]
.col50[
.card.bg-b[
##### Inheritance
.content.tight[
**Inheritance** captures the **is a** relationship. It allows building more complex objects by extending the capabilities, etc.
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
]
.botbody.oldsections[
#### Composition

.col50[
```java[name=Point.java|lite=1]
class Point {
  private double x;
  private double y;
}
â€‹
```

.card.bg-y[
##### Responsibilities
.content.tight[
X- and Y-coordinates
- Compute distance
- Coord transform
- .note18[etc]
]
.content.tight[
.op0[
&rArr; Delegate to `Point` if needed
]
]
]
]
.col50[
```java[name=Circle.java|lite=2]
class Circle {
  private Point center;
  private double radius;
}
â€‹
```

.card.bg-y[
##### Responsibilities
.content.tight[
Area around center point
- Compute area
- Check if inside
- .note18[etc]
]
.content.tight[
&rArr; Delegate to `Point` if needed
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
]
.botbody.oldsections[
#### Inheritance

.col50[
```java[name=ColoredCircle.java|lite=2]
class ColoredCircle 
    extends Circle {
  private Color color;
  // Others are inherited!
}
```

.card.bg-y[
##### Responsibilities
.content.tight[
Colors
- Change color
- Check color
- .note18[etc]
]
.content.tight[
&rArr; Delegate to `Circle` if needed
]
]
]
.col50[
```java[name=Circle.java|lite=1]
class Circle {
  private Point center;
  private double radius;
}
â€‹
```

.card.bg-y[
##### Responsibilities
.content.tight[
Area around center point
- Compute area
- Check if inside
- .note18[etc]
]
.content.tight[
.op0[
&rArr; Delegate to `Point` if needed
]
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
#### Polymorphism
]
.botbody.oldsections[
#### Polymorphism

.col100[
.font18[
```java[copy=nones]
void say(Object obj) {
  if (obj instanceof Point) {
    Point pt = (Point) obj;
    System.out.println("Hi, I am " + "(" + pt.getX() + 
        ", " + pt.getY() + ")");
  } else if (obj instanceof Circle) {
    Circle circ = (Circle) obj;
    // ... code omitted ...
  }
}
```
]
.card.bg-r[
##### Symptom
.content.tight[
Containing .X[`if`-`else`] related to type (e.g., .X[`instanceof`] or .X[`obj.tag == TAG`]).
Here, `TAG` is typically just an integer.<br><br>
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
#### Polymorphism
]
.botbody.oldsections[
#### Polymorphism

.col100[
.font18[
```java[copy=nones|lite=2,6]
void say(Object obj) {
  if (obj instanceof Point) {
    Point pt = (Point) obj;
    System.out.println("Hi, I am " + "(" + pt.getX() + 
        ", " + pt.getY() + ")");
  } else if (obj instanceof Circle) {
    Circle circ = (Circle) obj;
    // ... code omitted ...
  }
}
```
]
.card.bg-y[
##### Step #1
.content.tight[
.X[Identify types involved] (e.g., `Point` and `Circle` but may come from `TAG`).
Create a .note18[(potentially abstract)] class for each type .note18[(if not already)].
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
#### Polymorphism
]
.botbody.oldsections[
#### Polymorphism

.col100[
.font18[
```java[copy=nones|lite=1]
void say(Object obj) {
  if (obj instanceof Point) {
    Point pt = (Point) obj;
    System.out.println("Hi, I am " + "(" + pt.getX() +
        ", " + pt.getY() + ")");
  } else if (obj instanceof Circle) {
    Circle circ = (Circle) obj;
    // ... code omitted ...
  }
}
```
]
.card.bg-y[
##### Step #2
.content.tight[
.X[Identify common superclass] .note18[(if any)] or create one if not already present.
Create a .note18[(potentially abstract)] common method in the superclass.
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
#### Polymorphism
]
.botbody.oldsections[
#### Polymorphism

.col100[
.font18[
```java[copy=nones|lite=3,4,7,8]
void say(Object obj) {
  if (obj instanceof Point) {
    Point pt = (Point) obj;
    System.out.println("Hi, I am " + "(" + pt.getX() +
        ", " + pt.getY() + ")");
  } else if (obj instanceof Circle) {
    Circle circ = (Circle) obj;
    // ... code omitted ...
  }
}
```
]
.card.bg-y[
##### Step #3
.content.tight[
.X[Override the common method] in identified subclass.
The behavior is as identified in the non-polymorphic code.<br><br>
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
#### Polymorphism
]
.botbody.oldsections[
#### Polymorphism

.col100[
.font18[
```java[copy=nones|lite=2]
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```
]
]

##### Related Concepts
.col50[
.card.bg-y[
##### Dynamic Binding
.content.tight[
Which method is invoked?
- Compile-time steps
- Run-time steps
]
]
]
.col50[
.card.bg-y[
##### Overriding
.content.tight[
Redefining methods.
- Satisfy LSP
- May return subtype
]
]
]

.vs10[]

.col100[
.card.bg-y[
##### Common Concepts
.content.tight[
.X[Match] .note18[(i.e., matching method descriptor)] is used in both dynamic binding and overriding.
]
]
]
]

---

.topsub.subsections[
### Abstraction
#### Principle
#### Composition
#### Inheritance
#### Polymorphism
]
.botbody.oldsections[
#### Polymorphism

.col100[
##### Generality of Abstract Classes
```py[copy=nones]
from abc import ABC, abstractmethod
# abc is abstract base class

class Shape():
  @abstractmethod
  def getArea(self):
    pass
```
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
]
.botbody.oldsections[
#### Principle

.col100[
.card.bg-g[
##### The Generalization Principle
.content.tight[
**Generalization** extracts common components such that the code can be written in one place.
Changes in functionalities .note18[(i.e., specialization)] can be done via parameterization and .note18[(if possible)] changes should only happen in one place.
]
]
]

.vs10[]

.col100[
.card.bg-b[
##### Boilerplate Reduction
.content.tight[
Both **composition** and **inheritance** also reduces boilerplate codes.
Other techniques includes:
]
.content.tight.flexcard[
.col17[
- .X[Variable]
- .X[Function]
- .X[Generic]
- .X[Lambda]
]
.col83.nol[
- Generalization of values.
- Generalization of simple computations.
- Generalization of types.
- Higher-order generalizations.
]
]
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
]
.botbody.oldsections[
#### Var &rArr; Func

.col100[
.font20[
```java[copy=nones]
String lsName = user.getLastName();
if (lsName == null) {
  lsName = "";
}
show(lsName.toUpperCase());
```
```java[copy=nones]
String fsName = user.getFirstName();
if (fsName == null) {
  fsName = "";
}
show(fsName.toUpperCase());
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
]
.botbody.oldsections[
#### Var &rArr; Func

.col100[
.font20[
```java[copy=nones|emph=2-5]
String lsName = user.getLastName();
if (lsName == null) {
  lsName = "";
}
show(lsName.toUpperCase());
```
```java[copy=nones|emph=2-5]
String fsName = user.getFirstName();
if (fsName == null) {
  fsName = "";
}
show(fsName.toUpperCase());
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
]
.botbody.oldsections[
#### Var &rArr; Func

.col100[
.font20[
```java[copy=nones|lite=1]
String name = user.getLastName();
if (name == null) {
  name = "";
}
show(name.toUpperCase());
```
```java[copy=nones|lite=1]
String name = user.getFirstName();
if (name == null) {
  name = "";
}
show(name.toUpperCase());
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
]
.botbody.oldsections[
#### Var &rArr; Func

.col100[
.font20[
```java[copy=nones]
void showName(String name) {
  if (name == null) {
    name = "";
  }
  show(name.toUpperCase());
}
```
```java[copy=nones|lite=1]
showName(user.getLastName());
```
```java[copy=nones|lite=1]
showName(user.getFirstName());
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
]
.botbody.oldsections[
#### Var &rArr; Func

.col100[
.font20[
```java[copy=nones]
PhoneNumber phoneNumber = user.getOfficeNum();
if (phoneNumber == null) {
  phoneNumber = user.getMainLineNum();
}
save(phoneNumber.toString());
```
```java[copy=nones]
PhoneNumber mobileNumber = user.getMobileNum();
if (mobileNumber == null) {
  mobileNumber = user.getMainLineNum();
}
save(mobileNumber.toString());
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
]
.botbody.oldsections[
#### Var &rArr; Func

.col100[
.font20[
```java[copy=nones|emph=2-5]
PhoneNumber num         = user.getOfficeNum();
if (num         == null) {
  num         = user.getMainLineNum();
}
save(        num.toString());
```
```java[copy=nones|emph=2-5]
PhoneNumber num          = user.getMobileNum();
if (num          == null) {
  num          = user.getMainLineNum();
}
save(         num.toString());
```
]
]
.col100[
.font20[
```java[copy=nones|lite=2-5]
void savePhone(PhoneNumber num, User user) {
  if (num == null) {
    num = user.getMainLineNum();
  }
  save(num.toString());
}
```
```java[copy=nones]
savePhone(user.getOfficeNum(), user);
savePhone(user.getMobileNum(), user);
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
#### Type &rArr; &lt;T&gt;
]
.botbody.oldsections[
#### Type &rArr; &lt;T&gt;

.col100[
.font20[
```java[copy=nones]
class NameDefaultPair {
  private String name;
  private String defName;
}
```
```java[copy=nones]
class UserPhonePair {
  private User user;
  private PhoneNumber num;
}
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
#### Type &rArr; &lt;T&gt;
]
.botbody.oldsections[
#### Type &rArr; &lt;T&gt;

.col100[
.font20[
```java[copy=nones]
class Pair<T, S> {
  private T first;
  private S second;
}
```
```java[copy=nones]
// NameDefaultPair
new Pair<String, String>(..);
// UserPhonePair
new Pair<User, PhoneNumber>(..);
```
]
]

.col100[
.card.bg-r[
##### Limitation
.content.tight[
After generalization, we cannot perform operations specific to the classes.
]
.content.tight[
**Relevant Concepts:** .note22[invariance], .note22[covariance], .note22[contravariance], .note22[PECS], .note22[type erasure], .note18[etc].
]
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
#### Type &rArr; &lt;T&gt;
#### Ops &rArr; .math[&lambda;]
]
.botbody.oldsections[
#### Ops &rArr; .math[&lambda;]

.col100[
.font20[
```java[copy=nones]
void showName(String name, String defName) {
  if (name == null) { name = defName; }
  show(name.toUpperCase());
}
```
]
]
.col100[
.font20[
```java[copy=nones]
void savePhone(PhoneNumber num, User user) {
  if (num == null) { num = user.getMainLineNum(); }
  save(num.toString());
}
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
#### Type &rArr; &lt;T&gt;
#### Ops &rArr; .math[&lambda;]
]
.botbody.oldsections[
#### Ops &rArr; .math[&lambda;]

.col100[
.font20[
```java[copy=nones|emph=2-3]
void showName(String name, String defName) {
  if (name == null) { name = defName; }
  show(name.toUpperCase());
}
```
]
]
.col100[
.font20[
```java[copy=nones|emph=2-3]
void savePhone(PhoneNumber num, User user) {
  if (num == null) { num = user.getMainLineNum(); }
  save(num.toString());
}
```
]
]

.col100[
.font20[
```java[copy=nones|lite=4-5]
void handle(T item, Producer<T> p,
      Transformer<T, String> t,
      Consumer<String> c) {
  if (item == null) { item = p.produce(); }
  c.consumer(t.transform(item));
}
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
#### Principle
#### Var &rArr; Func
#### Var &rArr; Func2
#### Type &rArr; &lt;T&gt;
#### Ops &rArr; .math[&lambda;]
]
.botbody.oldsections[
#### Ops &rArr; .math[&lambda;]

.col100[
.font20[
```java[copy=nones|lite=2-3]
void showName(String name, String defName) {
  handle(name, () -> "", nm -> nm.toUpperCase(),
      nm -> show(nm));
}
```
]
]
.col100[
.font20[
```java[copy=nones|lite=2-3]
void savePhone(PhoneNumber num, User user) {
  handle(num, () -> user.getMainLineNum(),
      us -> us.toString(), us -> save(us));
}
```
]
]

.col100[
.font20[
```java[copy=nones]
void handle(T item, Producer<T> p,
      Transformer<T, String> t,
      Consumer<String> c) {
  if (item == null) { item = p.produce(); }
  c.consumer(t.transform(item));
}
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
#### Principle
]
.botbody.oldsections[
#### Principle

.col100[
.card.bg-g[
##### Principle of Minimization of Effect of Changing Implementation
.content.tight[
When the client does not know the implementation details of a class/method, they are not dependent on the specific way it has been implemented.
]
.content.tight[
.note18[&rArr; You can make a change to how something is computed and the client is none the wiser.]
]
]
]

.vs10[]

.col50[
.card.bg-b[
##### Information Hiding
.content.tight[
Information details should be hidden from the client.<br><br>
]
.content.tight[
Any functionalities should be codified as API .note18[(i.e., public methods)].
]
]
]
.col50[
.card.bg-b[
##### LSP
.content.tight[
A subclass should not break the expectation of the superclass.
]
.content.tight[
We need to be clear on what is the **"desirable property"**.
]
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
#### Principle
#### Information Hiding
]
.botbody.oldsections[
#### Information Hiding

.col100[
.atbl.blhead.font20[
| Keyword | from Same Class | from Other Class |
|---|:-:|:-:|
| `private` | <i class="fa fa-square-check dgntxt"></i> | <i class="fa fa-square-xmark drdtxt"></i> |
| `public` | <i class="fa fa-square-check dgntxt"></i> | <i class="fa fa-square-check dgntxt"></i> |
]

.card.bg-b[
##### Good Practice
.content.tight[
- Whenever possible, set everything to `private`.
    - Decide carefully if a field/method needs to be `public`.
- Whenever possible, do not provide accessors/mutators.
]
]
]

.vs10[]

.col100[
.img70.center[![Private](img/02-Private.jpg)]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
#### Principle
#### Information Hiding
#### LSP
]
.botbody.oldsections[
#### LSP

.col100[
.card.bg-r[
##### Common Mistake
.content.tight[
Substitutability does **NOT** simply mean "has a subtype relationship".
]
.content.tight[
Just because a class inherits from another class, does not mean it is substitutable.
]
]
]
]

.vs10[]

##### Example
.col100[
```java[copy=nones]
Rectangle r1 = new Rectangle(3, 3);
Rectangle r2 = new Square(3, 3);
r1.setHeight(2);
r2.setHeight(2);
```
]
.col100[
.card.bg-y[
##### Desirable Property
.content.tight.nol[
- Rectangle can change height/weight independently.
- Square must have both the same value.
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
### Others
#### Comments
]
.botbody.oldsections[
#### Comments

.col100[
![Comment](img/12-Comments.jpg)
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
### Others
#### Comments
]
.botbody.oldsections[
#### Comments

.col100[
.font20[
```java[copy=nones]
// initial range of [startn, end] is
// [0, array.length-1]

// while [start, end] is not empty
  // compute mid-point

  // if value equal to mid-point
    // we found the value
  // if value smaller than mid-point
    // value is in [start, mid]
  // if value larger than mid-point
    // value is in [mid, end]
    â€‹
    â€‹
// not found
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
### Others
#### Comments
]
.botbody.oldsections[
#### Comments

.col100[
.font20[
```java[copy=nones]
int start = 0;
int end = array.length - 1;

while (start <= end) {
  int mid = (start + end) / 2;

  if (value == array[mid]) {
    return mid;
  } else if (value < array[mid]) {
    end = mid;
  } else {
    start = mid;
  }
}
return -1;
```
]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
### Others
#### Comments
#### Compiler
]
.botbody.oldsections[
#### Compiler

.col100[
.card.bg-g[
##### Compiler is Your Friend
.content.tight[
Compilers can catch errors early
]
.content.tight[
.nol[
- but only errors related to types according to _compile-time_ type
]
]
.content.tight[
.nol[
- and errors related to dynamic features .note18[(explicit type casting, etc)] cannot be completely checked
]
]
]
]

.vs10[]

.col100[
.img70.center[![Compiler](img/12-Compiler.jpg)]
]
]

---

.topsub.subsections[
### Abstraction
### Generalization
### Minimization
### Others
#### Comments
#### Compiler
#### Motto
]
.botbody.oldsections[
#### Motto

.col100[
.card.bg-b[
##### Useful Quote
.content.tight[
_"Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live"_

.right[John Woods]
]
]

.vs10[]

.card.bg-y[
##### Other Relevant Skills
.content.tight[
Always cultivate good habit to help with programming.
]
]
]
]

---
name: Stone
class: sections

.topsub.subsections[
### Immutability
#### Immutable
]
.botbody.oldsections[
#### Immutable

.col100[
.card.bg-g[
##### Definition
.content.tight[
An **immutable class** is a class for which there cannot be any visible changes outside of its abstraction barrier.
]
]
]

.vs10[]

.col50[
.card.bg-y[
##### Isolating Moving Parts
.content.tight[
How to minimize moving parts?
.nol[
- &rArr; Have no moving parts.
- &rArr; Be _unchanging_.
]
]
]
]
.col50[
.card.bg-b[
##### Benefits
.content.tight[
- Allows sharing of internals
- Easier concurrency.op0[&rArr;]
- Easier reasoning.op0[&rArr;]
]
]
]
]

---

.topsub.subsections[
### Immutability
#### Immutable
#### Moving Parts
]
.botbody.oldsections[
#### Moving Parts

.col100[
##### with.op0[out] Moving Parts
```java[copy=nones]
      class Circle {
  private       double x;
  private       double y;
  private       double r;
    :
  public void   moveTo(double x, double y) {
    this.x = x;
    this.y = y;
  }
}
```
]
]

---

.topsub.subsections[
### Immutability
#### Immutable
#### Moving Parts
]
.botbody.oldsections[
#### Moving Parts

.col100[
##### without Moving Parts
```java[copy=nones]
final class Circle {
  private final double x;
  private final double y;
  private final double r;
    :
  public Circle moveTo(double x, double y) {
    Circle res = new Circle(x, y, this.r);
    return res;
  }
}
```
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
]
.botbody.oldsections[
#### Pure

.col100[
.card.bg-g[
##### Definition
.content.tight[
A pure function .note18[(denoted mathematically as `f` : `X` &rarr; `Y`)] is a mapping from the domain `X` to the codomain `Y`.
For each `x` âˆˆ `X`, there is `y` âˆˆ `Y` such that `y` = `f(x)`.
]
.content.tight[
.note18[&rArr; Deterministic ; Referentially Transparent ; No Side-Effect]
]
]
]

.vs10[]

.col100[
.card.bg-r[
##### Side-Effect
.content.tight[
1. Print to monitor
2. Write to files
3. Throw exceptions
4. Assign or mutate fields
5. .note18[... any other effects visible by the caller]

]
]
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
]
.botbody.oldsections[
#### Higher-Order

.col100[
##### Step #1: Convention
.font18[
```java[copy=nones]
class AddOne {
  Integer transform(Integer x) { return x + 1; }
}
```
.op0[
```java[copy=nones]
class AddOne implements Transformer {
  Integer transform(Integer x) { return x + 1; }
}
```
]
```java[copy=nones]
Integer app(AddOne f, Integer x) {
  return f.transform(x);
}
```
]
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
]
.botbody.oldsections[
#### Higher-Order

.col100[
##### Step #2: Interface
.font18[
```java[copy=nones]
interface Transformer {
  Integer transform(Integer x);
}
```
```java[copy=nones]
class AddOne implements Transformer {
  Integer transform(Integer x) { return x + 1; }
}
```
```java[copy=nones]
Integer app(Transformer f, Integer x) {
  â€‹
  return f.transform(x);
}
```
]
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
]
.botbody.oldsections[
#### Higher-Order

.col100[
##### Step #3: Generic
.font18[
```java[copy=nones]
interface Transformer<T, R> {
  R transform(T x);
}
```
```java[copy=nones]
class AddOne implements Transformer<Integer, Integer> {
  Integer transform(Integer x) { return x + 1; }
}
```
```java[copy=nones]
Integer app(Transformer<? super Integer,
    ? extends Integer> f, Integer x) {
  return f.transform(x);
}
```
]
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction

.col100[
##### Abstraction of Computation
![Composition](img/12-Comp01.png)
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction

.col100[
##### Abstraction of Computation
![Composition](img/12-Comp02.png)
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction

.col100[
##### Abstraction of Computation
![Composition](img/12-Comp03.png)
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction

.col100[
##### Abstraction of Computation
![Composition](img/12-Comp04.png)
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction

.col100[
##### Abstraction of Computation
![Composition](img/12-Comp05.png)
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction

.col100[
##### Abstraction of Computation
![Composition](img/12-Comp06.png)
]
]
.footnote[Here, `(g.f)(x)` is `f(g(x))`.]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction
##### Abstraction of Dependency

.col100[
![Composition](img/12-Comp07.png)
]
.col100[
```java[copy=nones]
public static Box  <Z> foo(Box  <X> x) {
  Box  <Y> y = x.map(f);
  Box  <Z> z = y.map(g);
  return z;
}
```
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction
##### Abstraction of Dependency

.col100[
![Composition](img/12-Comp07.png)
]
.col100[
```java[copy=nones]
public static Maybe<Z> foo(Maybe<X> x) {
  Maybe<Y> y = x.map(f);
  Maybe<Z> z = y.map(g);
  return z;
}
```
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction
##### Abstraction of Dependency

.col100[
![Composition](img/12-Comp07.png)
]
.col100[
```java[copy=nones]
public static Lazy <Z> foo(Lazy <X> x) {
  Lazy <Y> y = x.map(f);
  Lazy <Z> z = y.map(g);
  return z;
}
```
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction
##### Abstraction of Dependency

.col100[
![Composition](img/12-Comp07.png)
]
.col100[
```java[copy=nones]
public static Monad<Z> foo(Monad<X> x) {
  Monad<Y> y = x.map(f);
  Monad<Z> z = y.map(g);
  return z;
}
```
]

.col100[
.card.notes[
##### Note
.content.tight[
This is actually a **functor** as we are using .X[`map`].
Adaptation to **monad** can be easily made by adding .X[`flatMap`].
]
.content.tight[
But we also have to satisfy all monad properties.
]
]
]
]

---

.topsub.subsections[
### Immutability
### Functions
#### Pure
#### Higher-Order
#### Higher-Abstraction
]
.botbody.oldsections[
#### Higher-Abstraction
##### Abstraction of Dependency

.col100[
![Composition](img/12-Comp07.png)
]
.col100[

.col50[
```java[copy=nones]
â€‹
  return x.map(f)
          .map(g);
 â€‹
 â€‹
```
]
.col50[
```java[copy=nones]
â€‹
  y = f(x);
  z = g(y);
  return z;
 â€‹
```
]

.col100[
.card.notes[
##### Note
.content.tight[
We focus on the **essence** of computation .uline[_with respect to_] the dependencies.
]
]
]
]
]

---
name: Stream
class:  sections

.topsub.subsections[
### Abstraction
#### as Context
]
.botbody.oldsections[
#### as Context

.col100[
.atbl.blhead[
| Monad | Context .op0[XXXXXXXXXXXXXXXXXXXXXXXX] |
|---|---|
| `Maybe<T>` | The answer may be missing |
| `Lazy<T>` | The answer is computed when needed and memoized |
| `Stream<T>` | The answer is one of the item in the stream |
| `CompletableFuture<T>` | The answer will be available when you need it .note18[(no control over when it is actually ready)] |
]
]
]

---

.topsub.subsections[
### Abstraction
#### as Context
#### as Abstraction
]
.botbody.oldsections[
#### as Abstraction

.col100[
.atbl.blhead[
| Monad | Context .op0[XXXXXXXXXXXXXXXXXXXXXXXX] |
|---|---|
| `Maybe<T>` | Abstracting conditionals |
| `Lazy<T>` | Abstracting lazy evaluation<br><br> |
| `Stream<T>` | Abstracting loops<br><br> |
| `CompletableFuture<T>` | Abstracting asynchronous computation<br><br> |
]
]
]

---

.topsub.subsections[
### Abstraction
### Unloop
#### Trace
]
.botbody.oldsections[
#### Trace

.col100[
##### Code
.font20[
```java[copy=nones]
// Sum of square of odd number up to n
sum = 0;
for (int i = 0; i < n; i++) {
  if (i % 2 == 1) {
    sum += i * i;
  }
}
```
]
]
.col100[
##### Trace Table
.atbl.blhead.font20[
| Iter | | `i` | `sum` | | `i * i` | `sum += i * i` |
|---|---|---|---|---|---|---|
| 1 | | 0 | 0 | |.tbl-cell[tbl-bg-r] - |.tbl-cell[tbl-bg-r] - |
| 2 | | 1 | 0 | | 1 | 1 |
| 3 | | 2 | 1 | |.tbl-cell[tbl-bg-r] - |.tbl-cell[tbl-bg-r] - |
| 4 | | 3 | 1 | | 9 | 10 |
| 5 | | 4 | 10 | |.tbl-cell[tbl-bg-r] - |.tbl-cell[tbl-bg-r] - |
| : | | : | : | | : | : |
]
]
]

---

.topsub.subsections[
### Abstraction
### Unloop
#### Trace
]
.botbody.oldsections[
#### Trace

.col100[
##### Code
.font20[
```java[copy=nones]
// Sum of square of odd number up to n
sum = 0;
for (int i = 0; i < n; i++) {
  if (i % 2 == 1) {
    sum += i * i;
  }
}
```
]
]
.col100[
##### Transposed
.atbl.blhead.font20[
| Iter | 1 | 2 | 3 | 4 | 5 | ... |
|---|---|---|---|---|---|---|
|.tbl-row[tbl-bg-k] | | | | | | |
| `i` | 0 | 1 | 2 | 3 | 4 | ... |
| `sum` | 0 | 0 | 1 | 1 | 10 | ... |
|.tbl-row[tbl-bg-k] | | | | | | |
| `i * 1` |.tbl-cell[tbl-bg-r] - | 1 |.tbl-cell[tbl-bg-r] - | 9 |.tbl-cell[tbl-bg-r] - | ... |
| `sum += i * i` |.tbl-cell[tbl-bg-r] - | 1 |.tbl-cell[tbl-bg-r] - | 10 |.tbl-cell[tbl-bg-r] - | ... |
]
]
]

---

.topsub.subsections[
### Abstraction
### Unloop
#### Trace
]
.botbody.oldsections[
#### Trace

.col100[
##### Code
.font20[
```java[copy=nones]
// Sum of square of odd number up to n
sum = 0;
for (int i = 0; i < n; i++) {
  if (i % 2 == 1) {
    sum += i * i;
  }
}
```
]
]
.col100[
##### Stream
.atbl.blhead.font20[
| Iter | 1 | 2 | 3 | 4 | ... |
|---|---|---|---|---|---|
| `.iterate(...)` | 0 | 1 | 2 | 3 | ... |
| `.filter(...)` |.tbl-cell[tbl-bg-r] - | 1 | .tbl-cell[tbl-bg-r] - | 3 | ... |
| `.map(...)` |.tbl-cell[tbl-bg-r] - | 1 | .tbl-cell[tbl-bg-r] - | 9 | ... |
| `.reduce(...)` | _sum_ |
]
]
]

---

.topsub.subsections[
### Abstraction
### Unloop
#### Trace
]
.botbody.oldsections[
#### Trace

.col100[
##### Code
.font20[
```java[copy=nones]
// Sum of square of odd number up to n
sum = 0;
for (int i = 0; i < n; i++) {
  if (i % 2 == 1) {
    sum += i * i;
  }
}
```
]
]
.col100[
##### Stream
.font20[
```java[copy=nones]
// Sum of square of odd number up to n
Stream.iterate(0,
          i -> i < n,
          i -> i + 1)
      .filter(i -> i % 2 == 1)
      .map(i -> i * i)
      .reduce(0,
          (acc, elem) -> acc + elem,
          (ac1, ac2) -> ac1 + ac2);
```
]
]
]

---
name: Function
class: sections

.topsub.subsections[
### FP
#### Comparison
]
.botbody.oldsections[
#### Comparison

.col50[
.card.bg-y[
##### Functional
.content.tight[
- Functions are first-class citizen
- Avoids side-effect
- Referentially transparent
    - Easy to reason
- Focus on computation
- Data as thin containers
]
]
]
.col50[
.card.bg-y[
##### Object-Oriented
.content.tight[
- Objects are first-class citizen
- Objects are mutable
- Polymorphism
    - Easy to extend
- Focus on state
- Data has functionalities
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
]
.botbody.oldsections[
#### Comparison

.col100[
##### Functional
.font20[
```java[copy=nones]
int fact(int n) {
  return Stream
    .iterate(1, i -> i <= n, i -> i+1)
    .reduce(1, (res, i) -> res * i);
}
// Stream as an abstraction of loop
//   (more correctly, non-determinism)
```
]
]
.col100[
##### Object-Oriented
.font20[
```java[copy=nones]
int fact(int n) {
  int res = 1;
  for (int i=1; i<=n; i=i+1) {
    res = res * i;
  }
  return res;
}
```
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
]
.botbody.oldsections[
#### OOP Problem

.col50[
.font18[
```java[name=Circle.java|copy=nones]
class Circle <: Shape {
  double x;
  double y;
  double r; // radius
  
  double getArea() { .. }
  â€‹
  â€‹
}
```
]
]
.col50[
.font18[
```java[name=Square.java|copy=nones]
class Square <: Shape {
  double x;
  double y;
  double s; // side

  double getArea() { .. }
  â€‹
  â€‹
}
```
]
]
.col50.op0[
.font18[
```java[name=Triangle.java|copy=nones]
class Triangle <: Shape {
  double x;
  double y;
  double z;

  double getArea() { .. }
  â€‹
  â€‹
} // Easy!!!
```
]
]
.col50[
.card.bg-r[
##### Question
.content.tight[
Add a new type called `Triangle`.
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
]
.botbody.oldsections[
#### OOP Problem

.col50[
.font18[
```java[name=Circle.java|copy=nones]
class Circle <: Shape {
  double x;
  double y;
  double r; // radius

  double getArea() { .. }
  â€‹
  â€‹
}
```
]
]
.col50[
.font18[
```java[name=Square.java|copy=nones]
class Square <: Shape {
  double x;
  double y;
  double s; // side

  double getArea() { .. }
  â€‹
  â€‹
}
```
]
]
.col50[
.font18[
```java[name=Triangle.java|copy=nones]
class Triangle <: Shape {
  double x;
  double y;
  double z;

  double getArea() { .. }
  â€‹
  â€‹
} // Easy!!!
```
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
]
.botbody.oldsections[
#### OOP Problem

.col50[
.font18[
```java[name=Circle.java|copy=nones]
class Circle <: Shape {
  double x;
  double y;
  double r; // radius
  
  double getArea() { .. }
  â€‹
  â€‹
}
```
]
]
.col50[
.font18[
```java[name=Square.java|copy=nones]
class Square <: Shape {
  double x;
  double y;
  double s; // side
  
  double getArea() { .. }
  â€‹
  â€‹
}
```
]
]
.col50[
.font18[
```java[name=Triangle.java|copy=nones]
class Triangle <: Shape {
  double x;
  double y;
  double z;
  
  double getArea() { .. }
  â€‹
  â€‹
} // Easy!!!
```
]
]

.col50[
.card.bg-r[
##### Question
.content.tight[
Add a new abstract function `getPerimeter` into `Shape`.
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
]
.botbody.oldsections[
#### OOP Problem

.col50[
.font18[
```java[name=Circle.java|copy=nones|lite=7,8]
class Circle <: Shape {
  double x;
  double y;
  double r; // radius
  
  double getArea() { .. }
  double getPerimeter()
    { .. }
}
```
]
]
.col50[
.font18[
```java[name=Square.java|copy=nones|lite=7,8]
class Square <: Shape {
  double x;
  double y;
  double s; // side

  double getArea() { .. }
  double getPerimeter()
    { .. }
}
```
]
]
.col50[
.font18[
```java[name=Triangle.java|copy=nones|lite=7,8]
class Triangle <: Shape {
  double x;
  double y;
  double z;
  
  double getArea() { .. }
  double getPerimeter()
    { .. }
}
```
]
]

.col50[
.card.warns[
##### Issue
.content.tight[
You have to add on all subclasses if the behavior are all different!
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
]
.botbody.oldsections[
#### FP Problem

.col100[
.font18[
```java[name=GetArea.java|copy=nones]
double getArea(Shape shape) {
  if (shape instanceof Circle) {
      :
  } else if (shape instanceof Square) {
      :
  }
}
```
]
]
.col100[
.card.bg-r[
##### Question
.content.tight[
Add a new type called `Triangle`.
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
]
.botbody.oldsections[
#### FP Problem

.col100[
.font18[
```java[name=GetArea.java|copy=nones|lite=6-8]
double getArea(Shape shape) {
  if (shape instanceof Circle) {
      :
  } else if (shape instanceof Square) {
      :
  } else if (shape instanceof Triangle) {
      :
  }
}
```
]
]
.col100[
.card.warns[
##### Issue
.content.tight[
We need to modify all existing functions that takes in `Shape`.
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
]
.botbody.oldsections[
#### FP Problem

.col100[
.font18[
```java[name=GetArea.java|copy=nones]
double getArea(Shape shape) {
  if (shape instanceof Circle) {
      :
  } else if (shape instanceof Square) {
      :
  } else if (shape instanceof Triangle) {
      :
  }
}
```
]
]
.col100[
.card.bg-r[
##### Question
.content.tight[
Add a new function `getPerimeter` taking in `Shape`.
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
]
.botbody.oldsections[
#### FP Problem

.col100[
.font18[
```java[name=GetArea.java|copy=nones]
double getArea(Shape shape) { // UNCHANGED!
  if (shape instanceof Circle) {
      :
  } else if (shape instanceof Square) {
      :
  } else if (shape instanceof Triangle) {
      :
  }
}
```
]
]
.col100[
.font18[
```java[name=GetPerimeter.java|copy=nones]
double getPerimeter(Shape s) {
  if (shape instanceof Circle) {
      :
  } else if(shape instanceof Square) {
      :
  } else if (shape instanceof Triangle) {
      :
  }
}
```
]
]

.col100[
.card.notes[
##### Note
.content.tight[
The advantage here is that `GetArea.java` need not be recompiled.
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
#### Dual Problem
]
.botbody.oldsections[
#### Dual Problem

.col50[
##### OOP
.atbl[
|   |.tbl-cell[tbl-bg-b] getArea |.tbl-cell[tbl-bg-r] new Function |
|---|:-:|:-:|
|.tbl-cell[tbl-bg-y] **Circle** | .dbltxt[**âœ”**] | ðŸ˜± |
|.tbl-cell[tbl-bg-y] **Square** | .dbltxt[**âœ”**] | ðŸ˜± |
|.tbl-cell[tbl-bg-g] **new Type** | ðŸ˜ƒ |.tbl-cell[tbl-bg-k] |
]
]
.col50[
##### FP
.atbl[
|   |.tbl-cell[tbl-bg-b] getArea |.tbl-cell[tbl-bg-g] new Function |
|---|:-:|:-:|
|.tbl-cell[tbl-bg-y] **Circle** | .dbltxt[**âœ”**] | ðŸ˜ƒ |
|.tbl-cell[tbl-bg-y] **Square** | .dbltxt[**âœ”**] | ðŸ˜ƒ |
|.tbl-cell[tbl-bg-r] **new Type** | ðŸ˜± |.tbl-cell[tbl-bg-k] |
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
#### Dual Problem
]
.botbody.oldsections[
#### Dual Problem
##### Choose the Right Tool for the Job

.col100[
<iframe width="100%" height="430" src="https://www.youtube-nocookie.com/embed/6pDH66X3ClA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
#### Dual Problem
#### OOP & FP
]
.botbody.oldsections[
#### OOP & FP

.col50[
.img80.center[![FP](img/12-FP01.jpg)]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
#### Dual Problem
#### OOP & FP
]
.botbody.oldsections[
#### OOP & FP

.col50[
.img80.center[![FP](img/12-FP01.jpg)]
]
.col50[
.img80.center[![FP](img/12-FP02.jpg)]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
#### Dual Problem
#### OOP & FP
]
.botbody.oldsections[
#### OOP & FP

.col50[
.img80.center[![FP](img/12-FP01.jpg)]
]
.col50[
.img80.center[![FP](img/12-FP02.jpg)]
]
.col100[
.card.bg-b[
##### Quote
.content.tight[
_"OO programming is good, when you know what it is. Functional programming is good, when you know what it is. And functional OO programming is also good, once you know what it is."_

.right[Uncle Bob]
]
]
]
]

---

.topsub.subsections[
### FP
#### Comparison
#### OOP Problem
#### FP Problem
#### Dual Problem
#### OOP & FP
#### Other Choices
]
.botbody.oldsections[
#### Other Choices

.col100[
.atbl.blhead[
| Paradigms | Languages |
|---|---|
| Parallel/Concurrent | Erlang, Go, etc |
| Functional | Haskell, Erlang, OCaml, F#, etc |
| OO Functional | JavaScript, Kotlin, Scala, OCaml, Groovy, Swift, etc |
]
]
]

---
name: Future
class: sections

.topsub.subsections[
### CS2103<sub>T</sub>
]
.botbody.oldsections[
#### Intro to Software Engineering
- Work in teams
- Version control
- Program analysis
.nol[
-   :
]

.col100[
<iframe width="100%" height="430" src="https://nusmods.com/courses/CS2103T/software-engineering" frameborder="0" ></iframe>
]
]

---

.topsub.subsections[
### CS2103<sub>T</sub>
### CS2104.op0[<sub>T</sub>]
]
.botbody.oldsections[
#### Programming Language Concepts
- Implementations of language
- Compilation
- Interpretation
.nol[
-   :
]

.col100[
<iframe width="100%" height="430" src="https://nusmods.com/courses/CS2104/programming-language-concepts" frameborder="0" ></iframe>
]
]

---

.topsub.subsections[
### CS2103<sub>T</sub>
### CS2104.op0[<sub>T</sub>]
### CS3210.op0[<sub>T</sub>]
]
.botbody.oldsections[
#### Parallel Computing
- Designing and programming multi-threaded programs
- Debugging multi-threaded programs
- Parallelization with CPU/CUDA
.nol[
-   :
]

.col100[
<iframe width="100%" height="430" src="https://nusmods.com/courses/CS3210/parallel-computing" frameborder="0" ></iframe>
]
]


---

class: middle, end, fadein

.eol[`jshell> /exit`]


.eol[`| Goodbye`]