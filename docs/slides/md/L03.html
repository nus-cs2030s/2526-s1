layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga Sidi Prabawa</p></div>

---

name: L03
class: bottom, titles

# CS2030S
## Programming Methodology II
### L03: Polymorphism

.abs.top2.rt4[.img110[![QR](img/dcsaysp.png)]]

---
name: Polymorphism
class: sections

.topsub.subsections[
### Motivation
]
.botbody.oldsections[
#### Case Analysis

.col100[
.code-t[
```java[copy=nones]
class Drawer {
  static void draw(Circle c) {
```
]
.code-m.unrvl-tgl[
```text[copy=nones]
    if (c is a ColoredCircle)
    then
      print Color + " " + "Circle";
    otherwise
      print "Circle";
​
```
]
.code-m.rvl-tgl[
```java[copy=nones]
    if (c instanceof ColoredCircle) {
      ColoredCircle cc = (ColoredCircle) c;
      System.out.println(cc.getColor() + " Circle!");
    } else if (c instanceof Circle) {
      System.out.println("Circle!");
    }
```
]
.code-b[
```java[copy=nones]
  }
}
```
]
]

.vs10[]

.col100.rvl[
.card.bg-b[
##### Typecheck and Typecast
.content.tight[
- `obj instanceof Type`
.nol[
- checks if .X[`obj` is a subtype of `Type`]
]
- `T x = (T) y`
.nol[
- .X[explicit typecast] of `y` to `T`
]
]
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
#### Many Forms
]
.botbody.oldsections[
#### Many Forms

.col100[
```java[copy=nones]
class Drawer {
  static void draw(Circle c) {
    System.out.println(c.draw);
  }
}
```
]

.col100[
.card.bg-b[
##### Java Polymorphism
.content.tight[
Subclasses of a class can define their own .X[unique behaviors] and yet .X[share some of the same functionality] of the parent class.
]
.content.tight[
Using .X[method overriding], the same target of invocation .note18[(compile-time type)] can invoke different methods.
]
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
#### Many Forms
#### Warning #1
]
.botbody.oldsections[
#### Warning #1

.col100[
.center[
<video controls width="350" height="600px" muted><source src="vid/03-poly1.mp4" type="video/mp4" /></video>
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
#### Many Forms
#### Warning #1
#### Warning #2
]
.botbody.oldsections[
#### Warning #2

.col100[
.center[
<video controls width="500" height="600px" muted><source src="vid/03-poly2.mp4" type="video/mp4" /></video>
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
#### toString
]
.botbody.oldsections[
### Object
#### toString

.col100[
.card.bg-y[
##### Object::toString()
.content.tight[
Returns a .X[string representation] of the object.
]
]
]

.vs10[]

.col100[
```java[lite=6-9]
class Circle {
  private Point c;
  private double r;

  // : other methods omitted
  @Override
  public String toString() {
    return "(" + this.c + ", " + this.r + ")";
  }
}
```
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
#### toString
#### equals
]
.botbody.oldsections[
### Object
#### equals

.col100[
.card.bg-y[
##### Object::equals(Object)
.content.tight[
Indicates whether some other object is ".X[equal to]" this one.
]
]
]

.vs10[]

.col100[
```java[lite=6-13]
class Circle {
  private Point c;
  private double r;

  // : other methods omitted
  @Override
  public boolean equals(Object obj) {
    if (obj instanceof Circle) {
      Circle circle = (Circle) obj;
      return this.c.equals(circle.c)
          && this.r == circle.r;
    }
    return false;
  }
}
```
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
]
.botbody.oldsections[
#### Unrelated Class

.col100[
```java[lite=5-7]
class Circle {
  private Point c;
  private double r;

  public double getArea() {
    return PI * this.r * this.r
  }
}
```
]
.col100[
```java[lite=5-7]
class Square {
  private Point c;
  private double l;

  public double getArea() {
    return this.l * this.l
  }
}
```
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
#### No Implementation
]
.botbody.oldsections[
#### No Implementation

.col100[
.card.bg-b[
##### Abstract Classes
.content.tight[
Abstract classes are classes that .X[cannot be instantiated].  It may provide .X[no implementation] or .X[incomplete implementation] for its methods.
]
]
]

.vs10[]

.col100[
```java[lite=12]
abstract class Shape {
  private int numOfAxesOfSymmetry;

  public Shape(int numOfAxesOfSymmetry) {
    this.numOfAxesOfSymmetry = numOfAxesOfSymmetry;
  }

  public boolean isSymmetric() {     // concrete
    return this.numOfAxesOfSymmetry > 0;
  }

  abstract public double getArea();  // abstract
}
```
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
#### No Implementation
#### Issue
]
.botbody.oldsections[
#### Issue

.col100[
.card.bg-r[
##### Class Inheritance Rule
.content.tight[
A class can only inherit from .X[at most one] other classes. This limits the design as we cannot have a .X[fine-grained] inheritance of capability?
]
]
]

.vs10[]

.col100[
```java
abstract class Shape {
  abstract public double getArea();
}
```
]
.col100[
```java
abstract class Lines {
  abstract public double getPerimeter();
}
```
]

.col100[
.card.bg-r.rvl[
##### Cannot Compile
.content.tight[
```java[lite=1]
class Circle extends Shape, Lines {
  // : code omitted
  ​
}
```
]
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
### Interface
#### Capability
]
.botbody.oldsections[
#### Capability

.col100[
.card.bg-b[
##### Interface
.content.tight[
Interfaces are abstractions of what the .X[type can do].  It .X[has no concrete method].cite[].  All methods declared in an interface is .X[automatically `public`].
]
]
]

.vs10[]

.col100.unrvl-tgl[
```java
abstract class Shape {
  abstract public double getArea();
}
```
]
.col100.rvl-tgl[
```java
interface GetAreable {
  double getArea();
}
```
]
.col100[
```java
interface GetPerimeterable {
  double getPerimeter();
}
```
]

.col100.unrvl-tgl[
.card.bg-g[
##### Compile
.content.tight[
```java[lite=1-2]
class Circle extends Shape
    implements GetPerimeterable {
  // : code omitted
}
```
]
]
]
.col100.rvl-tgl[
.card.bg-g[
##### Compile
.content.tight[
```java[lite=1-2]
class Circle
    implements GetPerimeterable, GetAreable {
  // : code omitted
}
```
]
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
### Interface
#### Capability
#### Inheritance
]
.botbody.oldsections[
#### Inheritance

.col100[
.card.bg-b[
##### Rule
.content.tight[
If a class .X[`C`] implements an interface .X[`I`], then .X[`C` <: `I`].
]
.content.tight[
- A class can .X[extend] at most one class.
.nol[
- .note18[(including abstract class)]
]
- A class can .X[implement] zero or more interfaces.
- An interface can .X[extend] zero or more interfaces.
]
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
### Interface
#### Capability
#### Inheritance
#### Spectrum
]
.botbody.oldsections[
#### Spectrum

.col19[
![Spectrum](img/03-Concrete.png)
]
.col81[
.card.bg-g[
##### Concrete Class
.content.tight[
```java
class Circle {
  // : code omitted (concrete methods only)
}
```
]
]

.card.bg-y[
##### Abstract Class
.content.tight[
```java
abstract class Shape {
  // : code omitted
  //   (concrete + abstract methods)
}
```
]
]

.vs20[]

.card.warns[
##### Impure Interface
.content.tight[
We do .X.drdtxt[NOT] talk about this.
]
]

.card.bg-r[
##### Pure Interface
.content.tight[
```java
interface GetPerimeterable {
  // : code omitted (abstract methods only)
}
```
]
]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
### Interface
### Quizzes
#### Quiz #1
]
.botbody.oldsections[
#### Quiz #1

.col100[
.card.bg-r[
##### Question
.content.tight[
Consider the following class and the usage below.
Does the code compile?
]
]
]

.vs10[]

.col50[
```java
interface A { }
class B implements A { }
interface C { }
class D implements C { }
```
```java[copy=nones]
B b = new B();
D d = (D) b;
```
]

.mrq[
1. .quiz-choice[Yes: compile] .quiz-ans[0] .quiz-hint[NO: definitely incompatible]
2. .quiz-choice[No: not compile] .quiz-ans[1] .quiz-hint[YES: definitely incompatible]

.quizzes-time[90]
.quizzes-link[tOX6mPrKcT56O8NjGiIrF]
]
]

---

.topsub.subsections[
### Motivation
### Polymorphism
### Object
### Application
### Abstract Class
### Interface
### Quizzes
#### Quiz #1
#### Quiz #2
]
.botbody.oldsections[
#### Quiz #2

.col100[
.card.bg-r[
##### Question
.content.tight[
Consider the following class and the usage below.
Does the code compile?
]
]
]

.vs10[]

.col50[
```java
interface A { }
class B implements A { }
interface C { }
class D implements C { }
```

```java[copy=nones]
A a = new B();
D d = (D) a;
```
]

.mrq[
1. .quiz-choice[Yes: compile] .quiz-ans[1] .quiz-hint[YES: potentially compatible]
2. .quiz-choice[No: not compile] .quiz-ans[0] .quiz-hint[YES: potentially compatible]

.quizzes-time[90]
.quizzes-link[jVRWv4fBI1JqqGTq0V3SX]
]
]

---

name: Break
class: middle, break

# Break

<br>

## <i class="fa-regular fa-clock break-icon"></i>

---
name: Dynamic_Binding
class: sections

.topsub.subsections[
### Motivation
]
.botbody.oldsections[
#### Case Analysis

.col100[
```java[copy=nones]
class CircleStorage {
  private Circle c1;
  private ColoredCircle c2;

  // : code omitted

  void store(Circle c) {
    if (c instanceof ColoredCircle) {
      this.c2 = (ColoredCircle) c;
    } else {
      this.c1 = c;
    }
  }
}
```
]
]

---

.topsub.subsections[
### Motivation
### Overloading
]
.botbody.oldsections[
#### Split

.col100[
```java[copy=nones]
class CircleStorage {
  private Circle c1;
  private ColoredCircle c2;

  // : code omitted

  void store(Circle c) {
    this.c1 = c;
  }
  void store(ColoredCircle c) {
    this.c2 = c;
  }
}
```
]

.col100[
.card.bg-b[
##### Method Overloading
.content.tight[
Method .U[overloading] happens when two or more methods in the same class have the .X[same name but different method signature].
]
]
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
#### Selections
]
.botbody.oldsections[
#### Selections

.col100[
```java
CircleStorage store = new CircleStorage();
Point p = new Point(0, 0);

​
Circle c1 = new Circle(p, 1);                       // 1
store.store(c1);

Circle c2 = new ColoredCircle(p, 1, "Blue");        // 2
store.store(c2);

ColoredCircle c3 = new ColoredCircle(p, 1, "Blue"); // 3
store.store(c3);
```
]

.vs10[]

.col100[
#### CircleStorage

```java[lite=1,5]
void store(Circle c) {         // (a)
  this.c1 = c;
}

void store(ColoredCircle c) {  // (b)
  this.c2 = c;
}
```
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
#### Selections
#### More Selections
]
.botbody.oldsections[
#### More Selections

.col100[
```java[lite=8,11]
CircleStorage store = new CircleStorage();
Point p = new Point(0, 0);

​
Circle c1 = new Circle(p, 1);                       // 1
store.store(c1);

Object o1 = new Circle(p, 1);                       // 1a
store.store(o1);

Object o2 = new Object();                           // 1b
store.store(o2);
```
]

.vs10[]

.col100[
#### CircleStorage

```java[lite=1,5]
void store(Circle c) {         // (a)
  this.c1 = c;
}

void store(ColoredCircle c) {  // (b)
  this.c2 = c;
}
```
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
#### Selections
#### More Selections
#### Even More Selections
]
.botbody.oldsections[
#### Even More Selections

.col100[
```java[lite=4,8,11]
CircleStorage store = new CircleStorage();
Point p = new Point(0, 0);

// let DashedCircle <: Circle  but  </: ColoredCircle
Circle c1 = new Circle(p, 1);                       // 1
store.store(c1);

Circle d1 = new DashedCircle(p, 1);                 // 1c
store.store(d1);

DashedCircle d2 = new DashedCircle(p, 1);           // 1d
store.store(d2);
```
]

.vs10[]

.col100[
#### CircleStorage

```java[lite=1,5]
void store(Circle c) {         // (a)
  this.c1 = c;
}

void store(ColoredCircle c) {  // (b)
  this.c2 = c;
}
```
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
### Steps
#### Compile-Time
]
.botbody.oldsections[
#### Compile-Time

.col100[
```java[copy=nones]
curr.foo(arg)
```

.card.bg-g[
##### Steps
.content.tight[
1. Determine .X[CTT(`curr`)].
2. Find all .X[accessible] methods with name `foo` in CTT(`curr`).
3. Identify .X[applicable] methods from Step 2 based on
    - number of parameters, and
    - by .X[compatibility] of CTT(`arg`) to parameter.
4. Identify the .X[most specific] method from Step 3.
    - Check if method is .X[appropriate].
    - Record the .X[method descriptor].
]
]
]

.col100.abs.top67[
.col100[
.card.bg-y[
##### Most Specific
.content.tight[
A method .X[_M_] is more specific than a method .X[_N_] if the argumenst to .X[_M_] can be passed to .X[_N_] .U[without compilation error].
]
]
]
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
### Steps
#### Compile-Time
#### Runtime
]
.botbody.oldsections[
#### Runtime

.col100[
```java[copy=nones]
curr.foo(arg)
```

.card.bg-g[
##### Steps
.content.tight[
1. Retrieve  method descriptor from compile-time step.
2. Compute target reference RTT(`foo`) as .X[_curr_].
3. Locate method to invoke by identifying .X[matching] method descriptor.
    - While not found and .X[_curr_] has superclass, repeat search in the superclass.
]
]
]

.col100.abs.top67[
.col100[
.card.bg-y[
##### Matching
.content.tight[
A method .X[_M_] matches the method .X[_N_] if they have the same method signature and the return type of .X[_M_] is a .U[subtype] of the method .X[_N_].
]
]
]
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
### Steps
### Notes
]
.botbody.oldsections[
#### Important Notes

.col100[
.card.bg-b[
##### Note
.content.tight[
Dynamic binding is only used to invoke .X[instance method].  Class methods, instance fields, and class fields are resolved via .U[static binding].
]
]
]

.vs20[]

.col100[
.card.bg-g[
##### Important
.content.tight[
During runtime step, the runtime type of the argument .X[does not affect] which method is invoked.  Only the method descriptor .note18[(determine during compile-time step)] is important.
]
]
]

.vs20[]

.col100[
.card.warns[
##### Warning
.content.tight[
We use official Java Tutorial definition of [.U[polymorphism]](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html) that exclude overloading .note18[(~~static/ad-hoc polymorphism~~)], generic .note18[(~~parametric polymorphism~~)], etc .note18[(see e.g. the [following blog](https://krishna.github.io/posts/many-types-of-polymorphism/))].
]
]
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
### Steps
### Notes
### Quizzes
#### Quiz #1
]
.botbody.oldsections[
#### Quiz #1

.col100[
.card.bg-r[
##### Question
.content.tight[
Consider the following class and the usage below.
Which method is invoked by the following code?
]
]
]

.vs10[]

.col50[
```java
class A { }
class B extends A {
  public void foo(B b) { }
}
class C extends B {
  public void foo(A a) { }
}
```
```java
C obj = new C();
C arg = new C();
obj.foo(arg);
```
]

.mrq[
1. .quiz-choice[`B::foo(B)`] .quiz-ans[1] .quiz-hint[YES: more specific (although farther in hierarchy)]
2. .quiz-choice[`C::foo(A)`] .quiz-ans[0] .quiz-hint[NO: less specific (although nearer in hierarchy)]
3. .quiz-choice[Error] .quiz-ans[0] .quiz-hint[NO: we found a method]

.quizzes-time[120]
.quizzes-link[1HTLHailSKqnI5IRVGMDH]
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
### Steps
### Notes
### Quizzes
#### Quiz #1
#### Quiz #2
]
.botbody.oldsections[
#### Quiz #2

.col100[
.card.bg-r[
##### Question
.content.tight[
Consider the following class and the usage below.
Which method is invoked by the following code?
]
]
]

.vs10[]

.col50[
```java
class A { }
class B extends A {
  public void foo(B b) { }
}
class C extends B {
  public void foo(A a) { }
}
```
```java
B obj = new C();
A arg = new C();
obj.foo(arg);
```
]

.mrq[
1. .quiz-choice[`B::foo(B)`] .quiz-ans[0] .quiz-hint[NO: no match for foo(A) in class B or its superclasses]
2. .quiz-choice[`C::foo(A)`] .quiz-ans[0] .quiz-hint[NO: no match for foo(A) in class B or its superclasses]
4. .quiz-choice[Error] .quiz-ans[1] .quiz-hint[YES: no method found]

.quizzes-time[120]
.quizzes-link[n3PidVcTouNp6y8GZl2oP]
]
]

---

.topsub.subsections[
### Motivation
### Overloading
### Dynamic Binding
### Steps
### Notes
### Quizzes
### Caution
]
.botbody.oldsections[
#### Polymorphism + Dynamic Binding is Powerful

.col49.rvl-step[
```java
class Bird {
  public void fly() { .. }
}
```
.rvl-num[1]
]
.col51.rvl-step[
```java
class Penguin extends Bird {
  // can penguin fly?
}
```
.rvl-num[2]
]

.col100.abs.top30[
.col100[
.center[![Power](img/03-liskov.gif)]
]
]

.col100.abs.bot10[
.col100[
.card.bg-y[
##### Motto
.content.tight[
Whenever a .X[superclass is needed] .note18[(i.e., `S`)], a .X[subclass can be given] .note18[(i.e., `T`)].
]
]
]
]
]

---
name: LSP
class: sections

.topsub.subsections[
### LSP
]
.botbody.oldsections[
#### Definition

.content.tight[
The **Liskov Substitution Principle** .note18[(abbreviated LSP)] states
]
.col70[
.col100[
.card.bg-g[
##### Formally
.content.tight[
Let .X[ϕ(`x`)] be a property provable about objects `x` of type .X[_T_]. Then .X[ϕ(`y`)] .X[should be true] for objects `y` of type .X[_S_] where .X[_S_ <: _T_].
]
]
]

.vs10[]

.col100[
.card.bg-b.rvl-step[
##### Informally
.content.tight[
If .X[_S_] is a subclass of .X[_T_], then an object of type .X[_T_] .X[can be replaced] by that of type .X[_S_] .X[without changing the .U[desirable property]] of the program.
].rvl-num[1]
]
]

.vs10[]

.col100[
.card.bg-y.rvl-step[
##### Plain English
.content.tight[
A subclass .X[should not break the expectations] set by the superclass.
].rvl-num[2]
]
]
]
.col30[
![Barbara Liskov](img/03-Liskov.jpg)
]
]

---

.topsub.subsections[
### LSP
### Final
#### Preventing Changes
]
.botbody.oldsections[
#### Preventing Changes

.col100[
.card.bg-g[
##### Keyword
.content.tight[
The `final` keyword can be used to prevent
]
.content.tight[
- variable from being re-assigned
- method from being overidden
- classes from being inherited
]
]
]

.vs10[]

.col100[
```java
public final class Point {
  private final double x;
  private final double y;
  ​
  // : other methods omitted
  @Override
  public final String toString() {
    return "Point(" + this.x + ", " + this.y + ")";
  }
}
```
]
]

---

.topsub.subsections[
### LSP
### Final
#### Preventing Changes
#### String
]
.botbody.oldsections[
#### String

<iframe class="inline-frame" id="ifrm1" src="https://docs.oracle.com/en/java/javase/21/docs//api/java.base/java/lang/String.html" width="100%" height="600px" frameborder="0" ></iframe>
]

---

.topsub.subsections[
### LSP
### Final
### Quizzes
#### Quiz #1
]
.botbody.oldsections[
#### Quiz #1

.col100[
.card.bg-r[
##### Question
.content.tight[
Consider the following class.
Will the class compile?
]
]
]

.vs10[]

.col100[
```java
class A {
  private final int x;

  public A(int x, int y) {
    if (y > 0) {
      this.x = x;
    } else {
      this.x = -x;
    }
  }
}
```
]

.mrq[
1. .quiz-choice[Yes: compile] .quiz-ans[1] .quiz-hint[YES: only 1 assignment, if-else are disjoint]
2. .quiz-choice[No: not compile] .quiz-ans[0] .quiz-hint[NO: only 1 assignment, if-else are disjoint]

.quizzes-time[90]
.quizzes-link[BmjKtWjWM7T8tZmWdqQzX]
]
]

---
name: Reminders
class: sections

.topsub.subsections[
### Todo
]
.botbody.oldsections[
.col100[
.card.notes[
##### Weekly
.content.tight.todo[
- Read notes on [.U[Week 03]](https://nus-cs2030s.github.io/2526-s1/notes/week03/index.html) .note18[(finish before lecture)]
- Complete [.U[Diagnostic Quiz 3]](https://canvas.nus.edu.sg/courses/77787/quizzes/64359)
- Prepare .X[Problem Set 1] .note18[(discussion in recitation)]
]
]

.card.notes[
##### Catch-Up Session I
.content.tight.todo[
- .X[Sat, 30 Aug 2025] from 10:00 .note18[([link](https://nus-sg.zoom.us/j/89040015385?pwd=gRvWLNGHag6ruRhrhxi6tOm4WI0irh.1) ; passcode: 877226)]
    - [.U[Pigeonhole]](https://pigeonhole.at/OOPS) for asking questions
]
]

.card.warns[
##### Lab
.content.tight.todo[
- .X[Lab Exercise 1:] .U[VIM & Encapsulation]
    - Graded, timed, and in-class exercise
    - 2 tasks: 2nd task only after completing task 1
]
]

.card.notes[
##### Programming Exercises
.content.tight.todo[
- .X[Programming Exercise 1] will be released this week
    - Exercise 2 and 3 build upon Exercise 1
]
]
]
]

---

class: middle, end, fadein

.eol[`jshell> /exit`]


.eol[`| Goodbye`]