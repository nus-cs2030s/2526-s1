layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga Sidi Prabawa</p></div>

---

name: L10
class: bottom, titles

# CS2030S
## Programming Methodology II
### L10: Monad & Parallel Stream

.abs.top2.rt4[.img110[![QR](img/dcsaysp.png)]]
.abs.bot3.rt1.entry-refresh[<i class="fas fa-retweet"></i>]

---
name: Functor
class: sections

# Functor

.topsub.subsections[
### Motivation
]
.botbody.oldsections[
### Motivation
#### Box

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  public Box(T val) {
    this.val = val;
  }
​
  public T getVal() {
    return this.val;
  }
  ​
  // : other code omitted
}
```
]
]
.col50[
.card.bg-r[
##### Question
.content.tight[
Given a box of integer,
- .X[multiply]/.X[add] the value by .X[`n`].
]
.content.tight[
Given a box of String,
- find the .X[length] of the string.
]
]

.card.bg-b.rvl-tgl[
##### Steps
.content.tight[
1. Access the value
2. Transform the value
3. Put into a new box
]
]
]

.col100[]

.col50.rel.inblock[
<pre class="text-editor editor14" id="box01a" style="height:235px">
</pre>
]
.col50.rel.inblock[
<pre class="text-editor editor14" id="box01b" style="height:235px">
</pre>
]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
#### Box
]
.botbody.oldsections[
### Functor
#### Box

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
  }
}
```
]
]
.col50[
.card.bg-r.op0[
##### Question
.content.tight[
Given a box of integer,
- .X[multiply]/.X[add] the value by .X[`n`].
]
.content.tight[
Given a box of String,
- find the .X[length] of the string.
]
]

.card.bg-b[
##### Steps
.content.tight[
1. Access the value
2. Transform the value
3. Put into a new box
]
]
]

.col100[]

.col50.op0[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n));
// ??
box.map(n -> f(n)).map(n -> g(n));
// ??
box.map(n -> g(n)).map(n -> f(n));
// ??
box.map(n -> h(n));
// ??
```
]
]
.col50.op0[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n)); // x -> x
// Identity
box.map(n -> f(n)).map(n -> g(n));
// Composition
box.map(n -> g(n)).map(n -> f(n));
// -- may be non-commutative --
box.map(n -> h(n)); // g(f(x))
// Composition
```
]
]
]

.abs.rt6.top23.wt40.unrvl-step[
![Map](img/10-Map01a.jpg)
.unrvl-num[1]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01b.jpg)
.rvl-num[1].unrvl-num[2]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01c.jpg)
.rvl-num[2].unrvl-num[3]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01d.jpg)
.rvl-num[3].unrvl-num[4]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01e.jpg)
.rvl-num[4].unrvl-num[5]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01f.jpg)
.rvl-num[5].unrvl-num[6]
]
.abs.rt6.top23.wt40.rvl-step[
![Map](img/10-Map01a.jpg)
.rvl-num[6]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
#### Box
#### Properties
]
.botbody.oldsections[
### Functor
#### Properties

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
  }
}
```
]
]
.col50[
.card.bg-r.op0[
##### Question
.content.tight[
Given a box of integer,
- .X[multiply]/.X[add] the value by .X[`n`].
]
.content.tight[
Given a box of String,
- find the .X[length] of the string.
]
]

.card.bg-b[
##### Steps
.content.tight[
1. Access the value
2. Transform the value
3. Put into a new box
]
]
]

.col100[]

.col50.unrvl-tgl[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n));
// ??
box.map(n -> f(n)).map(n -> g(n));
// ??
box.map(n -> g(n)).map(n -> f(n));
// ??
box.map(n -> h(n));
// ??
```
]
]
.col50.rvl-tgl[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n)); // x -> x
// Identity
box.map(n -> f(n)).map(n -> g(n));
// Composition
box.map(n -> g(n)).map(n -> f(n));
// -- may be non-commutative --
box.map(n -> h(n)); // g(f(x))
// Composition
```
]
]
.col50.unrvl-tgl[
.font14[
```java
int id(int n) { return n; }
int f(int n) {
  return n + 1;
}
int g(int n) {
  return n * 2;
}
int h(int n) {
  return g(f(n));
}
```
]
]
.col50.rvl-tgl[
.card.bg-g[
##### Functor Law
.content.tight[
A .X[functor] has .note14[(at least)] .X[`of`] and .X[`map`] .note14[(may have different names)] obeying
]
.content.tight[
.fsize14[
1. .X[Identity]
.nol[
- &forall; `fct`: .X[`fct`]`.map(`.X[x -> x]`)` &equiv; .X[`fct`]
]
2. .X[Composition]
.nol[
- &forall; `fct`,`f`,`g`: .X[`fct`]`.map(`.X[`x -> f(x)`]`)`
- .op0[&forall; `fct`,`f`,`g`: .X[`fct`]]`.map(`.X[`x -> g(x)`]`)`
- &nbsp;&nbsp;&nbsp;&nbsp; &equiv;
- .X[`fct`]`.map(`.X[`x -> g(f(x))`]`)`
]
]
]
]
]
]

.abs.rt6.top23.wt40[
![Map](img/10-Map01a.jpg)
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
#### Box
#### Properties
#### Computation
]
.botbody.oldsections[
### Functor
#### Computation

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
      ​
      ​
  }
}
```
]
]
.col50[
.font14[
```java
String csCourse(String code) {
  if (code.startsWith("CS")) {
    return code;
  } else {
    return "";
  }
}
```
]
]

.col100[]

.col50[
.font14[
```java
int length(String s) {
  String s0 = s;
  String s1 = csCourse(s0);
  int i = s1.length();
  return i;
}
```
]
]
.col50[
.font14[
```java
int length(String s) {
  return new Box<String>(s)
      .map(s0 -> csCourse(s0))
      .map(s1 -> s1.length())
      .getVal();
}
```
]
]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
### Context
]
.botbody.oldsections[
### Context
#### NULL

.col50.unrvl-step[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
      ​
      ​
  }
}
```
].unrvl-num[2]
]
.col50.rvl-step[
.font14[
```java[lite=9-11|emph=8-13]
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
    if (this.val != null) {
      T val = this.val;
      S res = fn.transform(val);
      return new Box<S>(res);
    }
    return new Box<S>(null);
  }
}
```
].rvl-num[2]
]
.col50[
.font14[
```java[lite=5]
String csCourse(String code) {
  if (code.startsWith("CS")) {
    return code;
  } else {
    return null;
  }
}
```
]
<br>

.rvl-step[
![null](img/10-null.jpg)
.rvl-num[1]
]
]

.col100[]

.col50[
.font14[
```java
int length(String s) {
  String s0 = s;
  String s1 = csCourse(s0);
  int i = s1.length();
  return i;
}
```
]
]
.col50[
.font14[
```java
int length(String s) {
  return new Box<String>(s)
      .map(s0 -> csCourse(s0))
      .map(s1 -> s1.length())
      .getVal();
}
```
]
]
]

---
name: Monad
class: sections

# Monad

.topsub.subsections[
### Motivation
]
.botbody.oldsections[
### Motivation
#### Loggable

.col100.unrvl-step[
.font14[
```java
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  ​
  ​
  ​
  ​
​
  public Loggable<Integer> incr() {
    return new Loggable<>(this.val + 1, this.log + "; incr " + this.val);
  }
​
  ​
  ​
  ​
}
```
].unrvl-num[1]
]
.col100.rvl-step.unrvl-step[
.font14[
```java[lite=20]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  ​
  ​
  ​
  ​
​
  public Loggable<Integer> incr() {
    return new Loggable<>(this.val + 1, this.log + "; incr " + this.val);
  }
​
  public Loggable<Integer> double() {
    return new Loggable<>(this.val * 2, this.log + "; double " + this.val);
  }
}
```
].rvl-num[1].unrvl-num[2]
]
.col100.rvl-step[
.font14[
```java[lite=11-12]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> map(Transformer<T, S> fn) {
    T val = this.val;         S res = fn.transform(val);
    return new Loggable<S>(res, this.log + "; map " + this.val);
  }
​
  public Loggable<Integer> incr() {
    return new Loggable<>(this.val + 1, this.log + "; incr " + this.val);
  }
​
  public Loggable<Integer> double() {
    return new Loggable<>(this.val * 2, this.log + "; double " + this.val);
  }
}
```
].rvl-num[2]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
#### Attempt #1
]
.botbody.oldsections[
### Attempts
#### Attempt #1: Bi-Functor

.col100[
.font14[
```java[lite=11,13]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> map(Transformer<T, S> f1,
        Transformer<String, String> f2) {
    T val = this.val;         S res = f1.transform(val);
    String log1 = this.log;   String log2 = f2.transform(log1);
    return new Loggable<S>(val, log2);
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
#### Attempt #1
#### Attempt #2
]
.botbody.oldsections[
### Attempts
#### Attempt #2: Pair

.col100[
.font14[
```java[lite=12,13]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> map(Transformer<Pair<T, String>,
        Pair<S, String>> fn) {
    Pair<T, String> val = new Pair<>(this.val, this.log);
    Pair<S, String> res = fn.transform(val);
    return new Loggable<S>(res.getFirst(), res.getSecond());
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
#### Attempt #1
#### Attempt #2
#### Attempt #3
]
.botbody.oldsections[
### Attempts
#### Attempt #3: Simpler Pair

.col100[
.font14[
```java[lite=10,12]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> map(Transformer<T, Pair<S, String>> fn) {
    T val = this.val;
    Pair<S, String> res = fn.transform(val);
    return new Loggable<S>(res.getFirst(),
          this.log + ";" + res.getSecond());
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
#### Box + Context
]
.botbody.oldsections[
### Monad
#### Loggable = Box + Log

.col100[
.font14[
```java[lite=12]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> flatMap(Transformer<T, Loggable<S>> fn) {
    T val = this.val;
    Loggable<S> res = fn.transform(val);
    return new Loggable<S>(res.val, this.log + "; " + res.log);
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
#### Box + Context
]
.botbody.oldsections[
### Monad
#### Loggable = Box + Log

.col100[
.font14[
```java[lite=11-12,17-19]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> flatMap(Transformer<T, Loggable<S>> fn) {
    T val = this.val;
    Loggable<S> res = fn.transform(val);
    return new Loggable<S>(res.val, this.log + "; " + res.log);
  }

  public <S> Loggable<S> map(Transformer<T, S> fn) {
    T val = this.val;
    Loggable<S> res = fn.transform(val);
    return res;
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
#### Box + Context
]
.botbody.oldsections[
### Monad
#### Loggable = Box + Log

.col100[
.font14[
```java[lite=12]
class Loggable<T> {
  private final T val;
  private final String log;
​
  public Loggable(T val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public <S> Loggable<S> flatMap(Transformer<T, Loggable<S>> fn) {
    // We use map to implement flatMap
    Loggable<Loggable<S>> res = this.map(fn);
    return new Loggable<S>(res.val, this.log + "; " + res.log);
  }

  public <S> Loggable<S> map(Transformer<T, S> fn) {
    T val = this.val;
    Loggable<S> res = fn.transform(val);
    return res;
  }
}
```
]
]

.col50.rvl-tgl[
.font14[
```java
Loggable f(int n) {
  return new Loggable(
    n + 1, "(" + n + " + 1)");
}
Loggable g(int n) {
  return new Loggable(
    n * 2, "(" + n + " * 2)");
}
```
]
]
.col50.rvl-tgl[
.font14[
```java
Loggable log = new Loggable(5, "5");
log.flatMap(x -> f(x))
   .flatMap(x -> g(x));
```
]
]
]

---
name: Context
class: sections

# Context

.topsub.subsections[
### Side-Effect
#### Put Into Box
]
.botbody.oldsections[
### Side-Effect
#### Put Into Box

.col100[
##### Impure Function
```java[copy=nones]
Box<Integer> incr(Box<Integer> box) {
  return new Box<>(box.val() + this.ctx);
}
```
]
.col100[
##### Visualization
![Impure](img/10-Impure01.png)
]
]

---

# Context

.topsub.subsections[
### Side-Effect
#### Put Into Box
]
.botbody.oldsections[
### Side-Effect
#### Put Into Box

.col100[
##### Impure Function
```java[copy=nones]
Ctx<Integer> incr(Ctx<Integer> ctx) {
  return new Ctx<>(ctx.val() + ctx.ctx(), ctx.ctx());
}
```
]
.col100[
##### Visualization
![Impure](img/10-Impure02.png)
]
]

---

# Context

.topsub.subsections[
### Side-Effect
#### Put Into Box
#### Maybe
]
.botbody.oldsections[
### Side-Effect
#### Maybe

.col50[
##### Some to Some
![Some](img/10-Maybe01.png)
]
.col50[
##### None to None
![None](img/10-Maybe02.png)
]
.col100[
.card.bg-y[
##### Context/Side-Condition
.content.tight[
The context of `Maybe<T>` is that the data
- is present but may be `null` .note20[(`Some<T>`)]
- may be absent/missing .note20[(`None<T>`)]
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
#### Put Into Box
#### Maybe
#### Context
]
.botbody.oldsections[
### Side-Effect
#### Context

.col100[
.atbl.blhead[
| Container | Context |
|---|---|
| `Some<T>`<br>.note20[(before `Maybe<T>`)] | Item in a box |
| `Maybe<T>` | Item might be missing |
| `Lazy<T>` | Item is evaluated on demand and evaluated at most once |
| `Loggable<T>` | Item with oeprations on item logged .note20[(will be discussed shortly)] |
| `InfiniteList<T>` | Items in a lazily-evaluated sequence<br>.note20[(in some literature, the context is non-determinism)] |
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
]
.botbody.oldsections[
### Logger
#### Preliminary

.col100[
.card.bg-g[
##### Immutable Class Logger
.content.tight[
Create an immutable class `Logger` that stores an integer value `val` and records _all_ previous operations done to reach the current value .note20[(as a `String`)].
]
.content.tight[
###### Operations
- Increment the value of `val`
- Finding the absolute value of `val`
- .note20[Other?  But still logged?]
]
]

.card.bg-y[
##### Notation
.content.tight[
For simplicity of notation, we will use `X` &rarr; `Y` to denote a function that takes in type `X` as parameter and returns a type `Y`.
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
]
.botbody.oldsections[
### Logger
#### Preliminary

.col100[
.card.bg-g[
##### Immutable Class Logger
.content.tight[
Create an immutable class `Logger` that stores an integer value `val` and records _all_ previous operations done to reach the current value .note20[(as a `String`)].
]
]
]

##### Functions
.col5.hljs-num[
```text[copy=nones]
1
2
3
4
5
6
```
]
.col55[
```java[copy=nones]
int incr(int x) { // int -> int
  return x + 1;
}
int abs(int x) {  // int -> int
  return x > 0 ? x : -x;
}
```
]
.col40[
```jshell[copy=nones]
jshell> incr(1)
$.. ==> 2
jshell> abs(-1)
$.. ==> 1
jshell> abs(incr(incr(-5)))
$.. ==> 3
```
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
]
.botbody.oldsections[
### Logger
#### as a Pair

.col60[
##### Code
.col10.hljs-num[
.font20[
```text[copy=nones]
1
2
3
4
5
6
7
```
]
]
.col90[
.font20[
```java[copy=nones]
Pair<Integer,String> incrWithLog(int x) {
  return Pair.of(incr(x), "; incr " + x);
} // int -> Pair<Integer, String>
​
Pair<Integer,String> absWithLog(int x) {
  return Pair.of(abs(x), "; abs " + x);
} // int -> Pair<Integer, String>
```
]
]
]
.col40[
##### Class
.font20[
```java[copy=nones]
class Pair<T,S> {
  private final T first;
  private final S second;
  // private Pair(T, S)
  // static Pair::of(T, S)
  // Pair::getFirst()
  // Pair::getSecond()
  // Pair::toString()
  // Pair::equals(Object)
}
```
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
]
.botbody.oldsections[
### Logger
#### as a Pair

.col100[
##### Code
.col6.hljs-num[
.font20[
```text[copy=nones]
1
2
3
4
5
6
7
```
]
]
.col94[
.font20[
```java[copy=nones]
Pair<Integer,String> incrWithLog(Pair<Integer,String> p) {
  return Pair.of(incr(p.getFirst()), p.getSecond() + "; incr " + p.getFirst());
} // Pair<Integer, String> -> Pair<Integer, String>
​
Pair<Integer,String> absWithLog(Pair<Integer,String> p) {
  return Pair.of(abs(p.getFirst()), p.getSecond() + "; abs " + p.getFirst());
} // Pair<Integer, String> -> Pair<Integer, String>
```
]
]

.col6.hljs-num[
.font20[
```text[copy=nones]
1
2
3
4
```
]
]
.col94[
.font20[
```jshell[copy=nones]
jshell> Pair<Integer, String> p = Pair.of(1, "")
p ==> [1, ]
jshell> absWithLog(incrWithLog(incrWithLog(p)))
$.. ==> [3, ; incr 1; incr 2; abs 3]
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
#### as Loggable
]
.botbody.oldsections[
### Logger
#### as Loggable

.col100[
##### Impure Version
.col6.hljs-num[
.font18[
```text[copy=nones]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
]
]
.col94[
.font18[
```java[copy=nones]
class Loggable {
  private       int value;
  private       String log;
  public  Loggable(int value, String log) {
    this.value = value;
    this.log = log;
  }
  ​
  ​
  ​
  ​
  public void     incrWithLog() {
    this.value = incr(this.value); this.log = this.log + "; incr " + this.value;
  }
}
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
#### as Loggable
]
.botbody.oldsections[
### Logger
#### as Loggable

.col100[
##### Pure Version
.col6.hljs-num[
.font18[
```text[copy=nones]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
]
]
.col94[
.font18[
```java[copy=nones]
final class Loggable {
  private final int value;
  private final String log;
  private Loggable(int value, String log) {
    this.value = value;
    this.log = log;
  }
  // with variant Loggable::ofWithLog(int, String)
  public static Loggable of(int value) {
    return new Loggable(value, "");
  }
  public Loggable incrWithLog() {
    return new Loggable(incr(this.value),     this.log + "; incr " + this.value);
  }
}
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
#### as Loggable
]
.botbody.oldsections[
### Logger
#### as Loggable

.col100[
##### Basic Operations
.col6.hljs-num[
.font18[
```text[copy=nones]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
]
]
.col94[
.font18[
```java[copy=nones]
final class Loggable {
    : 
  public Loggable absWithLog() {
    return new Loggable(abs(this.value), this.log + "; abs " + this.value);
  }
  public Loggable dblWithLog() {
    return new Loggable(dbl(this.value), this.log + "; dbl " + this.value);
  }
  ​
  ​
  ​
  ​
  ​
  ​
}
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
#### as Loggable
]
.botbody.oldsections[
### Logger
#### as Loggable

.col100[
##### Extension to More Operations
.col6.hljs-num[
.font18[
```text[copy=nones]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
]
]
.col94[
.font18[
```java[copy=nones]
final class Loggable {
    : 
  public Loggable absWithLog() {
    return new Loggable(abs(this.value), this.log + "; abs " + this.value);
  }
  public Loggable dblWithLog() {
    return new Loggable(dbl(this.value), this.log + "; dbl " + this.value);
  }
  ​
  public Loggable map(Transformer<Integer, Integer> f) {
    int value = this.value;
    int res = f.transform(value);
    return new Loggable(res, this.log); // What to log?
  }
}
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
#### as Loggable
]
.botbody.oldsections[
### Logger
#### as Loggable

.col100[
##### Custom Log
.col6.hljs-num[
.font18[
```text[copy=nones]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
]
]
.col94[
.font18[
```java[copy=nones]
final class Loggable {
    : 
  public Loggable absWithLog() {
    return new Loggable(abs(this.value), this.log + "; abs " + this.value);
  }
  public Loggable dblWithLog() {
    return new Loggable(dbl(this.value), this.log + "; dbl " + this.value);
  }
  ​
  public Loggable flatMap(Transformer<Integer, Loggable> f) {
    int value = this.value;
    Loggable res = f.transform(value);
    return Loggable.compose(this, res);  // how to compose?
  }
}
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
#### Preliminary
#### as a Pair
#### as Loggable
]
.botbody.oldsections[
### Logger
#### as Loggable

.col100[
##### Custom Log
.col6.hljs-num[
.font18[
```text[copy=nones]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
]
]
.col94[
.font18[
```java[copy=nones]
final class Loggable {
    :
  // We keep the current value
  // We compose the log by concatenating
  //   old.log + curr.log
  private static Loggable compose(Loggable old, Loggable curr) {
    return new Loggable(curr.value, old.log + curr.log);
  }
  ​
  public Loggable flatMap(Transformer<Integer, Loggable> f) {
    int value = this.value;
    Loggable res = f.transform(value);
    return Loggable.compose(this, res);  // how to compose?
  }
}
```
]
]
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
### Flat Map
#### Usage
]
.botbody.oldsections[
### Flat Map
#### Usage

.col100[
##### Mini Lab 6

```java[copy=nones]
return Maybe.of(  dbase.get(student)  )
            .flatMap(std -> Maybe.of(std.get(module)))
            .flatMap(mod -> Maybe.of(mod.get(assessment)))
            .orElse(() -> "No such entry");
```
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
### Flat Map
#### Usage
]
.botbody.oldsections[
### Flat Map
#### Usage

.col100[
##### Mini Lab 6

```java[copy=nones]
return Maybe.of(  dbase.get(student)            ).flatMap(std -> Maybe.of(std
                       .get(module)            )).flatMap(mod -> Maybe.of(mod
                       .get(assessment)      )).orElse(() -> "No such entry");
                       ​
```
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
### Flat Map
#### Usage
]
.botbody.oldsections[
### Flat Map
#### Usage

.col100[
##### Mini Lab 6

```java[copy=nones]
                  dbase.get(student)
                       .get(module)
                       .get(assessment)
                       ​
```
]
]

---

# Context

.topsub.subsections[
### Side-Effect
### Logger
### Flat Map
#### Usage
]
.botbody.oldsections[
### Flat Map
#### Usage

.col100[
##### Mini Lab 6

```java[copy=nones]
            std = dbase.get(student);
            mod =   std.get(module);
            return  mod.get(assessment);
                       ​
```
]
]

---
name: Monad_&_Functor
class: sections

# Monad & Functor

.topsub.subsections[
### Monad
#### Definition
]
.botbody.oldsections[
### Monad

.col100[
.card.bg-g[
##### Definition
.content.tight[
A **monad** is a _structure_ with at least two methods called `of` and `flatMap` .note20[(may be called differently)] and obeying the **three** monad laws below:
1. **Left Identity Law**
.nol[
- `∀ x, f:` `Monad.of(`.hilite-y[`x`]`).flatMap(y ->`.op0[`.`].hilite-y[`f(y)`]`)`
- .op0[ `∀ x, f:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[ `∀ x, f:`] .hilite-y[`f(x)`]
]
2. **Right Identity Law**
.nol[
- `∀ monad:` .hilite-y[`monad`]`.flatMap(x -> Monad.of(x))`
- .op0[`∀ monad:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[`∀ monad:`] .hilite-y[`monad`]
]
3. **Associative Law**
.nol[
- `∀ monad, f, g:` `monad.flatMap(x -> f(x)`.hilite-y[`)`]`.flatMap(y -> g(y))`
- .op0[`∀ monad, f, g:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[`∀ monad, f, g:`] `monad.flatMap(x -> f(x).flatMap(x -> g(x))`.hilite-y[`)`]
]
]
]
]
]
.IMPORTANT[]

---

# Monad & Functor

.topsub.subsections[
### Monad
#### Definition
#### Left Identity Law
]
.botbody.oldsections[
### Monad

.col100[
.card.bg-b[
##### Left Identity Law
.content.tight.nol[
- `∀ x, f:` `Monad.of(`.hilite-y[`x`]`).flatMap(y ->`.op0[`.`].hilite-y[`f(y)`]`)`
- .op0[ `∀ x, f:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[ `∀ x, f:`] .hilite-y[`f(x)`]
]
]
]

.col50[
##### LHS
.font20[
```java[copy=nones]
Monad.of(x).flatMap(y -> f(y))
​
​
```
]
![Left](img/10-Monad01a.png)
]

.col50[
##### RHS
.font20[
```java[copy=nones]
f(x)
​
​
```
]
![Left](img/10-Monad01b.png)
]
]
.abs.rt0.top2.wt40.ft[
.card.bg-y[
.content.tight.flexcard[
.col45.nol[
.font20[
- `val: f(x)`
- `ctx: e ⊕ C`
]
]
.col10.nol[
.font20[
- `≡`
- `≡`
]
]
.col45.nol[
.font20[
- `val: f(x)`
- `ctx: C`
]
]
]
]
]

---

# Monad & Functor

.topsub.subsections[
### Monad
#### Definition
#### Left Identity Law
#### Right Identity Law
]
.botbody.oldsections[
### Monad

.col100[
.card.bg-b[
##### Right Identity Law
.content.tight.nol[
- `∀ monad:` .hilite-y[`monad`]`.flatMap(x -> Monad.of(x))`
- .op0[`∀ monad:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[`∀ monad:`] .hilite-y[`monad`]
]
]
]

.col50[
##### LHS
.font20[
```java[copy=nones]
monad.flatMap(y -> Monad.of(y))
​
​
```
]
![Right](img/10-Monad02a.png)
]

.col50[
##### RHS
.font20[
```java[copy=nones]
monad
​
​
```
]
![Right](img/10-Monad02b.png)
]
]
.abs.rt0.top2.wt40.ft[
.card.bg-y[
.content.tight.flexcard[
.col45.nol[
.font20[
- `val: x`
- `ctx: C ⊕ e`
]
]
.col10.nol[
.font20[
- `≡`
- `≡`
]
]
.col45.nol[
.font20[
- `val: x`
- `ctx: C`
]
]
]
]
]

---

# Monad & Functor

.topsub.subsections[
### Monad
#### Definition
#### Left Identity Law
#### Right Identity Law
#### Associative Law
]
.botbody.oldsections[
### Monad

.col100[
.card.bg-b[
##### Associative Law
.content.tight.nol[
- `∀ monad, f, g:` `monad.flatMap(x -> f(x)`.hilite-y[`)`]`.flatMap(y -> g(y))`
- .op0[`∀ monad, f, g:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[`∀ monad, f, g:`] `monad.flatMap(x -> f(x).flatMap(x -> g(x))`.hilite-y[`)`]
]
]
]

.col50[
##### LHS
.font20[
```java[copy=nones]
monad.flatMap(x -> f(x))
     .flatMap(y -> g(y))
     ​
```
]
![Assoc](img/10-Monad03a.png)
]

.col50[
##### RHS
.font20[
```java[copy=nones]
monad.flatMap(
  x -> f(x).flatMap(x -> g(x))
)
```
]
![Assoc](img/10-Monad03b.png)
]
]
.abs.rt0.top2.wt60.ft[
.card.bg-y[
.content.tight.flexcard[
.col45.nol[
.font20[
- `val: g(f(x))`
- `ctx: (C1 ⊕ C2) ⊕ C3`
]
]
.col10.nol[
.font20[
- `≡`
- `≡`
]
]
.col45.nol[
.font20[
- `val: g(f(x))`
- `ctx: C1 ⊕ (C2 ⊕ C3)`
]
]
]
]
]

---

# Monad & Functor

.topsub.subsections[
### Monad
### Functor
#### Definition
]
.botbody.oldsections[
### Functor

.col100[
.card.bg-g[
##### Definition
.content.tight[
A **functor** is a _structure_ with at least two methods called `of` and `map` .note20[(may be called differently)] and obeying the **two** functor laws below:
1. **Identity Law / Identity Morphism**
.nol[
- `∀ functor:` .hilite-y[`functor`]`.map(x -> x)`
- .op0[ `∀ functor:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[ `∀ functor:`] .hilite-y[`functor`]
]
2. **Composition Law / Composition Morphism**
.nol[
- `∀ functor, f, g:` `functor.map(x ->`.op0[`.`].hilite-y[`f(x)`]`).map(y ->`.op0[`.`].hilite-y[`g(y)`]`)`
- .op0[`∀ monad:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[`∀ monad:`] `functor.map(x ->`.op0[`.`].hilite-y[`g(f(x))`]`)`
]
]
]
]
]
.IMPORTANT[]

---

# Monad & Functor

.topsub.subsections[
### Monad
### Functor
#### Definition
#### Identity
]
.botbody.oldsections[
### Monad

.col100[
.card.bg-b[
##### Identity
.content.tight.nol[
- `∀ functor:` .hilite-y[`functor`]`.map(x -> x)`
- .op0[ `∀ functor:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[ `∀ functor:`] .hilite-y[`functor`]
]
]
]

.col50[
##### LHS
.font20[
```java[copy=nones]
functor.map(x -> x)
```
]
![Id](img/10-Functor01a.png)
]

.col50[
##### RHS
.font20[
```java[copy=nones]
functor
```
]
![Id](img/10-Functor01b.png)
]
]

---

# Monad & Functor

.topsub.subsections[
### Monad
### Functor
#### Definition
#### Identity
#### Composition
]
.botbody.oldsections[
### Monad

.col100[
.card.bg-b[
##### Composition
.content.tight.nol[
- `∀ functor, f, g:` `functor.map(x ->`.op0[`.`].hilite-y[`f(x)`]`).map(y ->`.op0[`.`].hilite-y[`g(y)`]`)`
- .op0[`∀ monad:`] &nbsp;&nbsp;&nbsp; &equiv;
- .op0[`∀ monad:`] `functor.map(x ->`.op0[`.`].hilite-y[`g(f(x))`]`)`
]
]
]

.col50[
##### LHS
.font20[
```java[copy=nones]
functor.map(x -> f(x)).map(y -> g(y))
```
]
![Comp](img/10-Functor02a.png)
]

.col50[
##### RHS
.font20[
```java[copy=nones]
functor.map(x -> g(f(x)))
```
]
![Comp](img/10-Functor02b.png)
]
]

---
name: Concurrent_&_Parallel
class: sections

# Recap

.topsub.subsections[
### Preliminary
#### Code
]
.botbody.oldsections[
### Preliminary
#### Code

.col100[
```java[copy=nones]
v1 = init;
v2 = f1(v1);
v3 = f2(v1);
v4 = g1(v2);
v5 = g3(v3);
v6 = h3(v5);
v7 = fn(v4, v3, v6);
v8 = gn(v7)
```
]
]

---

# Recap

.topsub.subsections[
### Preliminary
#### Code
#### Sequential
]
.botbody.oldsections[
### Preliminary
#### Sequential

.col100[
.img85.center[![Node](img/10-Parallel01.png)]
]
]
.abs.bot7.lt1.wt17[
.font18[
```java[copy=nones]
v1 = init;
v2 = f1(v1);
v3 = f2(v1);
v4 = g1(v2);
v5 = g3(v3);
v6 = h3(v5);
v7 = fn(v4,v3,v6);
v8 = gn(v7)
```
]
]

---

# Recap

.topsub.subsections[
### Preliminary
#### Code
#### Sequential
#### Concurrent
]
.botbody.oldsections[
### Preliminary
#### Concurrent

.col100[
.img85.center[![Node](img/10-Parallel02.png)]
]
]
.abs.bot7.lt1.wt17[
.font18[
```java[copy=nones]
v1 = init;
v2 = f1(v1);
v3 = f2(v1);
v4 = g1(v2);
v5 = g3(v3);
v6 = h3(v5);
v7 = fn(v4,v3,v6);
v8 = gn(v7)
```
]
]

---

# Recap

.topsub.subsections[
### Preliminary
#### Code
#### Sequential
#### Concurrent
#### Parallel
]
.botbody.oldsections[
### Preliminary
#### Parallel

.col100[
.img85.center[![Node](img/10-Parallel03.png)]
]
]
.abs.bot7.lt1.wt17[
.font18[
```java[copy=nones]
v1 = init;
v2 = f1(v1);
v3 = f2(v1);
v4 = g1(v2);
v5 = g3(v3);
v6 = h3(v5);
v7 = fn(v4,v3,v6);
v8 = gn(v7)
```
]
]

---

# Recap

.topsub.subsections[
### Preliminary
#### Code
#### Sequential
#### Concurrent
#### Parallel
#### Summary
]
.botbody.oldsections[
### Preliminary
#### Summary

.col50[
##### Sequential

.img90[![Multi](img/11-Multi01.png)]

##### Concurrent Multi-Tasking

.img90[![Multi](img/11-Multi03.png)]
]
.col50[
##### Multi-Processing

.img90[![Multi](img/11-Multi02.png)]

##### Multi-Threading

.img90[![Multi](img/11-Multi03.png)]
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
#### Sequential
]
.botbody.oldsections[
### IntStream

.col100[
```java
boolean isPrime(int n) {
  return IntStream.range(2, (int)Math.sqrt(n) + 1)
                  .noneMatch(x -> n % x == 0);
}
```

#### Sequential
```java
IntStream.range(2_030_000, 2_040_000)
​
         .filter(x -> isPrime(x))
         .forEach(System.out::println);
```
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
#### Sequential
#### Parallel
]
.botbody.oldsections[
### IntStream

.col100[
```java
boolean isPrime(int n) {
  return IntStream.range(2, (int)Math.sqrt(n) + 1)
                  .noneMatch(x -> n % x == 0);
}
```

#### Parallel
```java
IntStream.range(2_030_000, 2_040_000)
         .parallel()
         .filter(x -> isPrime(x))
         .forEach(System.out::println);
```
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
#### No Interference
]
.botbody.oldsections[
### Considerations
#### No Interference

```java
List<String> list = new ArrayList<>(List.of("Luke", "Leia", "Han"));
list.stream().peek(name -> { if (name.equals("Han")) {
                                list.add("Chewie");
                              } })
             .forEach(x -> {});  
```
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
#### No Interference
#### No Side Effect
]
.botbody.oldsections[
### Considerations
#### No Side Effect

```java
List<Integer> list = new ArrayList<>(
  Arrays.asList(1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29)
);

List<Integer> result = new ArrayList<>();
list.parallelStream().filter(x -> isPrime(x)).forEach(System.out::println);
list.parallelStream().filter(x -> isPrime(x)).forEach(x -> result.add(x));
list.parallelStream().filter(x -> isPrime(x)).toList(); 
```
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
#### API
]
.botbody.oldsections[
### Reduce
#### Reduce

<iframe frameborder=0 width=100% height=450px src="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"></iframe>
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
]
.botbody.oldsections[
### Reduce
#### Sequential

.col100[
.font18[
```java
T reduce(T e, BinaryOperator<T> f)
```
]

.img80[![Reduce](img/10-Reduce01.png)]
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
]
.botbody.oldsections[
### Reduce
#### Parallel

.col100[
.font18[
```java
T reduce(T e, BinaryOperator<T> f)
```
]

.img80[![Reduce](img/10-Reduce02.png)]
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
]
.botbody.oldsections[
### Reduce
#### Parallel

.col100[
.font18[
```java
<U> U reduce(U e, BiFunction<U,? super T,U> f, BinaryOperator<U> g)
```
]

.img80[![Reduce](img/10-Reduce03.png)]
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
#### Properties
]
.botbody.oldsections[
### Reduce
#### Properties

.col100[
.font18[
```java
<U> U reduce(U e, BiFunction<U,? super T,U> f, BinaryOperator<U> g)
```
]
]

##### Parallelizing Reduce

.col30[
- **Identity** `e`
.nol.op0[
- .note18[.]
]
]
.col70.nol[
- `g(e, x)` equal to `x`
    - .note18[for `T reduce(T e, BinaryOperator<T> f)`, then `f(e, x)` equal to `x`]
]

.col30[
- **Pure** `f` & `g`<br>
]
.col70.nol[
- `f` and `g` should be **pure** functions<br>
]

.col30.nol[
- **Associative** `f` & `g`
.nol[
- .note18.op0[not a necessary condition as `f` is going to be applied]
]
]
.col70.nol[
- `g(g(x, y), z)` equal to `g(x, g(y, z))`
.nol[
- .note18[not a necessary condition as `f` is going to be applied in the same order for each fragment `f(f(f(f(e, a1), a2), a3), a4)`]
]
]

.col30[
- **Compatible** `f` & `g`
]
.col70.nol[
- Read more about [**compatibility**](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#reduce%28java.lang.Object,java.util.function.BiFunction,java.util.function.BinaryOperator%29)
.nol[
- .note18[using our symbol, `g(x, f(e, y))` equals to `f(x, y)`]
]
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
#### Properties
#### Examples
]
.botbody.oldsections[
### Reduce
#### Examples

.col100[
##### Sum
```java
List<Integer> list = new ArrayList<Integer>();
for (int i=1; i<=10000; i++) {
  list.add(i);
}
list.stream().parallel().reduce(0, (acc, elem) -> acc + elem);  
```

##### Length
```java
List<String> list = List.of("CS", "2030", "S");
list.stream().parallel().reduce(0,
    (acc, elem) -> acc + elem.length(),
    (acc1, acc2) -> acc1 + acc2);
```  
]
]

---

# Recap

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
### Timing
]
.botbody.oldsections[
### Timing
#### Code

.col100[
.font20[
```java
class Timing {
  public static void main(String[] args) {
    Instant start = Instant.now();
    long count = IntStream.range(2_000_000, 3_000_000)
        .filter(x -> isPrime(x))
      //.parallel()
        .count();
    Instant stop = Instant.now();
    System.out.println("count: " + count);
    System.out.println("time : " + Duration.between(start, stop).toMillis() + " ms");
  }
}
```
]
]
]
.abs.rt0.top2.wt45[
.font18[
```java[copy=nones]
boolean isPrime(int n) {
  return IntStream.range(2, (int)Math.sqrt(n) + 1)
    //.parallel()
      .noneMatch(x -> n % x == 0);
}
```
]
]

---

class: middle, end, fadein

.eol[`jshell> /exit`]


.eol[`| Goodbye`]