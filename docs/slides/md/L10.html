layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga Sidi Prabawa</p></div>

---

name: L10
class: bottom, titles

# CS2030S
## Programming Methodology II
### L10: Monad & Parallel Stream

.abs.top2.rt4[.img110[![QR](img/dcsaysp.png)]]
.abs.bot3.rt1.entry-refresh[<i class="fas fa-retweet"></i>]

---
name: Functor
class: sections

# Functor

.topsub.subsections[
### Motivation
]
.botbody.oldsections[
### Motivation
#### Box

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  public Box(T val) {
    this.val = val;
  }
​
  public T getVal() {
    return this.val;
  }
  ​
  // : other code omitted
}
```
]
]
.col50[
.card.bg-r[
##### Question
.content.tight[
Given a box of integer,
- .X[multiply]/.X[add] the value by .X[`n`].
]
.content.tight[
Given a box of String,
- find the .X[length] of the string.
]
]

.card.bg-b.rvl-tgl[
##### Steps
.content.tight[
1. Access the value
2. Transform the value
3. Put into a new box
]
]
]

.col100[]

.col50.rel.inblock[
<pre class="text-editor editor14" id="box01a" style="height:235px">
</pre>
]
.col50.rel.inblock[
<pre class="text-editor editor14" id="box01b" style="height:235px">
</pre>
]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
#### Box
]
.botbody.oldsections[
### Functor
#### Box

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
  }
}
```
]
]
.col50[
.card.bg-r.op0[
##### Question
.content.tight[
Given a box of integer,
- .X[multiply]/.X[add] the value by .X[`n`].
]
.content.tight[
Given a box of String,
- find the .X[length] of the string.
]
]

.card.bg-b[
##### Steps
.content.tight[
1. Access the value
2. Transform the value
3. Put into a new box
]
]
]

.col100[]

.col50.op0[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n));
// ??
box.map(n -> f(n)).map(n -> g(n));
// ??
box.map(n -> g(n)).map(n -> f(n));
// ??
box.map(n -> h(n));
// ??
```
]
]
.col50.op0[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n)); // x -> x
// Identity
box.map(n -> f(n)).map(n -> g(n));
// Composition
box.map(n -> g(n)).map(n -> f(n));
// -- may be non-commutative --
box.map(n -> h(n)); // g(f(x))
// Composition
```
]
]
]

.abs.rt6.top23.wt40.unrvl-step[
![Map](img/10-Map01a.png)
.unrvl-num[1]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01b.png)
.rvl-num[1].unrvl-num[2]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01c.png)
.rvl-num[2].unrvl-num[3]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01d.png)
.rvl-num[3].unrvl-num[4]
]
.abs.rt6.top23.wt40.rvl-step.unrvl-step[
![Map](img/10-Map01e.png)
.rvl-num[4].unrvl-num[5]
]
.abs.rt6.top23.wt40.rvl-step[
![Map](img/10-Map01f.png)
.rvl-num[5]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
#### Box
#### Properties
]
.botbody.oldsections[
### Functor
#### Properties

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
  }
}
```
]
]
.col50[
.card.bg-r.op0[
##### Question
.content.tight[
Given a box of integer,
- .X[multiply]/.X[add] the value by .X[`n`].
]
.content.tight[
Given a box of String,
- find the .X[length] of the string.
]
]

.card.bg-b[
##### Steps
.content.tight[
1. Access the value
2. Transform the value
3. Put into a new box
]
]
]

.col100[]

.col50.unrvl-tgl[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n));
// ??
box.map(n -> f(n)).map(n -> g(n));
// ??
box.map(n -> g(n)).map(n -> f(n));
// ??
box.map(n -> h(n));
// ??
```
]
]
.col50.rvl-tgl[
.font14[
```java
Box<Integer> box = new Box<>(5);
  ​
box.map(n -> id(n)); // x -> x
// Identity
box.map(n -> f(n)).map(n -> g(n));
// Composition
box.map(n -> g(n)).map(n -> f(n));
// -- may be non-commutative --
box.map(n -> h(n)); // g(f(x))
// Composition
```
]
]
.col50.unrvl-tgl[
.font14[
```java
int id(int n) { return n; }
int f(int n) {
  return n + 1;
}
int g(int n) {
  return n * 2;
}
int h(int n) {
  return g(f(n));
}
```
]
]
.col50.rvl-tgl[
.card.bg-g[
##### Functor Law
.content.tight[
A .X[functor] has .note14[(at least)] .X[`of`] and .X[`map`] .note14[(may have different names)] obeying
]
.content.tight[
.fsize14[
1. .X[Identity]
.nol[
- &forall; `fct`: .X.hilite-y[`fct`]`.map(`.X.hilite-y[x -> x]`)` &equiv; .X.hilite-y[`fct`]
]
2. .X[Composition]
.nol[
- &forall; `fct`,`f`,`g`: .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> f(x)`]`)`
- .op0[&forall; `fct`,`f`,`g`: .X.hilite-y[`fct`]]`.map(`.X.hilite-y[`x -> g(x)`]`)`
- &nbsp;&nbsp;&nbsp;&nbsp; &equiv;
- .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> g(f(x))`]`)`
]
]
]
]
]
]

.abs.rt6.top23.wt40[
![Map](img/10-Map01f.png)
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
#### Box
#### Properties
#### Computation
]
.botbody.oldsections[
### Functor
#### Computation

.col50[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
      ​
      ​
  }
}
```
]
]
.col50[
.font14[
```java
String csCourse(String code) {
  if (code.startsWith("CS")) {
    return code;
  } else {
    return "";
  }
}
```
]
]

.col100[]

.col50[
.font14[
```java
int length(String s) {
  String s0 = s;
  String s1 = csCourse(s0);
  int i = s1.length();
  return i;
}
```
]
]
.col50[
.font14[
```java
int length(String s) {
  return new Box<String>(s)
      .map(s0 -> csCourse(s0))
      .map(s1 -> s1.length())
      .getVal();
}
```
]
]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
### Context
]
.botbody.oldsections[
### Context
#### NULL

.col50.unrvl-step[
.font14[
```java
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
        ​
    T val = this.val;
    S res = fn.transform(val);
    return new Box<S>(res);
      ​
      ​
  }
}
```
].unrvl-num[2]
]
.col50.rvl-step[
.font14[
```java[lite=9-11|emph=8-13]
class Box<T> {
  private final T val;
​
  // : other code omitted
​
  public <S> Box<S> map(
      Transformer<T, S> fn) {
    if (this.val != null) {
      T val = this.val;
      S res = fn.transform(val);
      return new Box<S>(res);
    }
    return new Box<S>(null);
  }
}
```
].rvl-num[2]
]
.col50[
.font14[
```java[lite=5]
String csCourse(String code) {
  if (code.startsWith("CS")) {
    return code;
  } else {
    return null;
  }
}
```
]
<br>

.rvl-step[
![null](img/10-null.jpg)
.rvl-num[1]
]
]

.col100[]

.col50[
.font14[
```java
int length(String s) {
  String s0 = s;
  String s1 = csCourse(s0);
  int i = s1.length();
  return i;
}
```
]
]
.col50[
.font14[
```java
int length(String s) {
  return new Box<String>(s)
      .map(s0 -> csCourse(s0))
      .map(s1 -> s1.length())
      .getVal();
}
```
]
]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
### Context
### Quizzes
#### Quiz #1
]
.botbody.oldsections[
### Quizzes
#### Quiz #1

.col45[
.card.bg-r[
##### Question
.content.tight[
Consider the class .X[`Box`] on the right.  Is it a functor?
]
]
.card.bg-g[
##### Functor Law
.content.tight[
.fsize14[
1. .X[Identity]
.nol[
- &forall; `fct`: .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> x`]`)`
  - &equiv; .X.hilite-y[`fct`]
]
2. .X[Composition]
.nol[
- &forall; `fct`,`f`,`g`:
  - .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> f(x)`]`)`
  - .op0[.X.hilite-y[`fct`]]`.map(`.X.hilite-y[`x -> g(x)`]`)`
  - &nbsp;&nbsp;&nbsp;&nbsp; &equiv;
  - .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> g(f(x))`]`)`
]
]
]
]
]
.col55[
.font14[
```java[lite=12]
class Box {
  private int v;
  private Box(int v) {
    this.v = v;
  }
  public static Box of(int v) {
    return new Box(v);
  }
  public Box f(Transformer
      <Integer, Integer> fn) {
    int val = fn.transform(this.v);
    int res = Math.max(this.v, val);
    return Box.of(res);
  }
}
```
]
]

.mrq.cmnt-s[
1. .quiz-choice[Yes] .quiz-ans[0] .quiz-hint[NO: violate both]
1. .quiz-choice[No, violate .X[identity] only] .quiz-ans[0] .quiz-hint[NO: violate composition]
1. .quiz-choice[No, violate .X[composition] only] .quiz-ans[1] .quiz-hint[YES: only this]
1. .quiz-choice[No, violate .X[both]] .quiz-ans[0] .quiz-hint[NO: only composition]

.quizzes-time[120]
]
]

---

# Functor

.topsub.subsections[
### Motivation
### Functor
### Context
### Quizzes
#### Quiz #1
#### Quiz #2
]
.botbody.oldsections[
### Quizzes
#### Quiz #2

.col45[
.card.bg-r[
##### Question
.content.tight[
Consider the class .X[`Box`] on the right.  Is it a functor?
]
]
.card.bg-g[
##### Functor Law
.content.tight[
.fsize14[
1. .X[Identity]
.nol[
- &forall; `fct`: .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> x`]`)`
  - &equiv; .X.hilite-y[`fct`]
]
2. .X[Composition]
.nol[
- &forall; `fct`,`f`,`g`:
  - .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> f(x)`]`)`
  - .op0[.X.hilite-y[`fct`]]`.map(`.X.hilite-y[`x -> g(x)`]`)`
  - &nbsp;&nbsp;&nbsp;&nbsp; &equiv;
  - .X.hilite-y[`fct`]`.map(`.X.hilite-y[`x -> g(f(x))`]`)`
]
]
]
]
]
.col55[
.font14[
```java[lite=12]
class Box {
  private int v;
  private Box(int v) {
    this.v = v;
  }
  public static Box of(int v) {
    return new Box(v);
  }
  public Box f(Transformer
      <Integer, Integer> fn) {
    int val = fn.transform(this.v);
    int res = this.v;
    return Box.of(res);
  }
}
```
]
]

.mrq.cmnt-s[
1. .quiz-choice[Yes] .quiz-ans[1] .quiz-hint[YES: but not useful]
1. .quiz-choice[No, violate .X[identity] only] .quiz-ans[0] .quiz-hint[NO: no violation]
1. .quiz-choice[No, violate .X[composition] only] .quiz-ans[0] .quiz-hint[NO: no violation]
1. .quiz-choice[No, violate .X[both]] .quiz-ans[0] .quiz-hint[NO: no violation]

.quizzes-time[120]
]
]

---
name: Monad
class: sections

# Monad

.topsub.subsections[
### Motivation
]
.botbody.oldsections[
### Motivation
#### Loggable

.col100.unrvl-step[
.font14[
```java
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  ​
  ​
  ​
  ​
  ​
​
  public Loggable incr() {
    return new Loggable(this.val + 1, this.log + "; incr " + this.val);
  }
​
  ​
  ​
  ​
}
```
].unrvl-num[1]
]
.col100.rvl-step.unrvl-step[
.font14[
```java[lite=21]
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  ​
  ​
  ​
  ​
  ​
​
  public Loggable incr() {
    return new Loggable(this.val + 1, this.log + "; incr " + this.val);
  }
​
  public Loggable double() {
    return new Loggable(this.val * 2, this.log + "; double " + this.val);
  }
}
```
].rvl-num[1].unrvl-num[2]
]
.col100.rvl-step[
.font14[
```java[lite=11-13]
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public Loggable map(Transformer<Integer, Integer> fn) {
    int val = this.val;
    int res = fn.transform(val);
    return new Loggable(res, this.log + "; map " + this.val);
  }
​
  public Loggable incr() {
    return new Loggable(this.val + 1, this.log + "; incr " + this.val);
  }
​
  public Loggable double() {
    return new Loggable(this.val * 2, this.log + "; double " + this.val);
  }
}
```
].rvl-num[2]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
#### Attempt #1
]
.botbody.oldsections[
### Attempts
#### Attempt #1: Bi-Functor

.col100[
.font14[
```java
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public Loggable map(Transformer<Integer, Integer> fn1,
        Transformer<String, String> fn2) {
    int val  = this.val;              String log = this.log;
    int rval = fn1.transform(val);    String rlog = fn2.transform(log);
    return new Loggable(rval, rlog);
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
#### Attempt #1
#### Attempt #2
]
.botbody.oldsections[
### Attempts
#### Attempt #2: Pair

.col100[
.font14[
```java
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public Loggable map(Transformer<Pair<Integer, String>,
        Pair<Integer, String>> fn) {
    Pair<Integer, String> val = new Pair<>(this.val, this.log);
    Pair<Integer, String> res = fn.transform(val);
    return new Loggable(res.getFirst(), res.getSecond());
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
#### Attempt #1
#### Attempt #2
#### Attempt #3
]
.botbody.oldsections[
### Attempts
#### Attempt #3: Simpler Pair

.col100[
.font14[
```java
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public Loggable map(Transformer<Integer, Pair<Integer, String>> fn) {
    ​
    int val = this.val;
    Pair<Integer, String> res = fn.transform(val);
    return new Loggable(res.getFirst(), this.log + "; " + res.getSecond());
  }
}
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
#### Box + Context
]
.botbody.oldsections[
### Monad
#### Loggable = Box + Log

.col100[
.font14[
```java[lite=14]
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) {
    this.val = val;
    this.log = log;
  }
​
  public Loggable flatMap(Transformer<Integer, Loggable> fn) {
    ​
    int val = this.val;
    Loggable res = fn.transform(val);
    return new Loggable(res.val, this.log + "; " + res.log);
  }                            // ^ composition of log
}
```
]
]

.col50.rvl-tgl[
.font14[
```java
Loggable f(int n) {
  return new Loggable(
    n + 1, "(" + n + " + 1)");
}
Loggable g(int n) {
  return new Loggable(
    n * 2, "(" + n + " * 2)");
}
```
]
]
.col50.rvl-tgl[
.font14[
```java
Loggable log = new Loggable(5, "5");
log.flatMap(x -> f(x))
   .flatMap(x -> g(x));
```
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
#### Box + Context
#### Properties
]
.botbody.oldsections[
### Monad
#### Properties

.col100.unrvl-tgl[
.font14[
```java[lite=14]
class Loggable {
  private final int val;
  private final String log;
​
  public Loggable(int val, String log) { .. }
​
  public Loggable flatMap(Transformer<Integer, Loggable> fn) {
    int val = this.val;
    Loggable res = fn.transform(val);
    return new Loggable(res.val, this.log + "; " + res.log);
  }                            // ^ composition of log
}
```
]
]
.col100.rvl-tgl[
.font14[
```java[lite=5-6]
class Loggable {
  private final int val;
  private final String log;
​
  private Loggable(int val, String log) { .. }
  public static Loggable of(int val) { return new Loggable(val, ""); }
​
  public Loggable flatMap(Transformer<Integer, Loggable> fn) {
    Loggable res = fn.transform(this.val);
    return new Loggable(res.val, this.log + "; " + res.log);
  }                            // ^ composition of log
}
```
]
]

.col100.abs.bot4[
.col100[
.card.bg-g[
##### Monad Law
.content.tight[
A .X[monad] has .note14[(at least)] .X[`of`] and .X[`flatMap`] .note14[(may have different names)] obeying
]
.content.tight.fsize14[
1. .X[Left Identity]
.nol[
- &forall; `x`,`f`: `Monad.of(`.X.hilite-y[`x`]`).flatMap(`.X.hilite-y[`y -> f(y)`]`)` &equiv; .X.hilite-y[`f(x)`]
]
2. .X[Right Identity]
.nol[
- &forall; `monad`: .X.hilite-y[`monad`]`.flatMap(x -> Monad.of(x))` &equiv; .X.hilite-y[`monad`]
]
3. .X[Associative]
.nol[
- &forall; `monad`,`f`,`g`: `monad.flatMap(x -> f(x)`.X.drdtxt.hilite-y[`)`]`.flatMap(y -> g(y))`
- .op0[&forall; `monad`,`f`,`g`: ] &equiv;
- .op0[&forall; `monad`,`f`,`g`:] `monad.flatMap(x -> f(x).flatMap(y -> g(y))`.X.drdtxt.hilite-y[`)`]
]
]
]
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
#### Box + Context
#### Properties
]
.botbody.oldsections[
### Monad
#### Properties

.col50.unrvl-step[
![FlatMap](img/10-FlatMap01a.png)
.unrvl-num[1]
]
.col50.rvl-step.unrvl-step[
![FlatMap](img/10-FlatMap01b.png)
.rvl-num[1].unrvl-num[2]
]
.col50.rvl-step.unrvl-step[
![FlatMap](img/10-FlatMap01c.png)
.rvl-num[2].unrvl-num[3]
]
.col50.rvl-step.unrvl-step[
![FlatMap](img/10-FlatMap01d.png)
.rvl-num[3].unrvl-num[4]
]
.col50.rvl-step.unrvl-step[
![FlatMap](img/10-FlatMap01e.png)
.rvl-num[4].unrvl-num[5]
]
.col50.rvl-step.unrvl-step[
![FlatMap](img/10-FlatMap01f.png)
.rvl-num[5].unrvl-num[6]
]
.col50.rvl-step[
![FlatMap](img/10-FlatMap01g.png)
.rvl-num[6]
]
.col50[
.card.bg-b[
##### Steps
.content.tight[
1. Access the value
2. Transform the value .note14[(with context)]
3. Compose the two contexts
]
]
]

.col100[.op0[.]]

.col100[
.font14[
```java
  public Loggable flatMap(Transformer<Integer, Loggable> fn) {
    int val = this.val;
    Loggable res = fn.transform(val);
    return new Loggable(res.val, this.log + "; " + res.log);
  }
```
]
]

.col100.abs.bot4[
.col100[
.card.bg-g[
##### Monad Law
.content.tight[
A .X[monad] has .note14[(at least)] .X[`of`] and .X[`flatMap`] .note14[(may have different names)] obeying
]
.content.tight.fsize14[
1. .X[Left Identity]
.nol[
- &forall; `x`,`f`: `Monad.of(`.X.hilite-y[`x`]`).flatMap(`.X.hilite-y[`y -> f(y)`]`)` &equiv; .X.hilite-y[`f(x)`]
]
2. .X[Right Identity]
.nol[
- &forall; `monad`: .X.hilite-y[`monad`]`.flatMap(x -> Monad.of(x))` &equiv; .X.hilite-y[`monad`]
]
3. .X[Associative]
.nol[
- &forall; `monad`,`f`,`g`: `monad.flatMap(x -> f(x)`.X.drdtxt.hilite-y[`)`]`.flatMap(y -> g(y))`
- .op0[&forall; `monad`,`f`,`g`: ] &equiv;
- .op0[&forall; `monad`,`f`,`g`:] `monad.flatMap(x -> f(x).flatMap(y -> g(y))`.X.drdtxt.hilite-y[`)`]
]
]
]
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
### Context
]
.botbody.oldsections[
### Context
#### Common Container

.col100[
.atbl.blhead[
| Monad | Context |
|---|---|
| .X[`Box<T>`] | Item in a box. |
| .X[`Maybe<T>`] | Item might be .X[missing]. |
| .X[`Lazy<T>`] | Item is evaluated .X[when needed] and .X[only once]. |
| .X[`Loggable<T>`] | Item with the .X[log of operations] on the item. |
| .X[`InfiniteList<T>`] | Item in a .X[lazily-evaluated] sequence.<br><br>Non-deterministic computation<br>.op0[....].note14[(the answer is one of the value in the list)]. |
]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
### Context
### Computation
]
.botbody.oldsections[
### Computation
#### Main Computation vs Contextual Computation

.col100[
.font14[
```java
return Maybe.of(   dbase.get(student)      )
            .flatMap(std -> Maybe.of(std.get(course)))
            .flatMap(crs -> Maybe.of(crs.get(assessment)))
            .orElse(() -> "No such entry");
```
]
]

.col100[.op0[.]]

.col100.rvl-step[
.font14[
```java
return Maybe.of(   dbase.get(student)      ).flatMap(std -> Maybe.of(std
                        .get(course)      )).flatMap(crs -> Maybe.of(crs
                        .get(assessment)  )).orElse(() -> "No such entry");
```
].rvl-num[1]
]

.col100[.op0[.]]

.col100.rvl-step[
.font14[
```java
                   dbase.get(student)
                        .get(course)
                        .get(assessment)                                  ;
```
].rvl-num[2]
]

.col100[.op0[.]]

.col100.rvl-step[
.font14[
```java
             std = dbase.get(student)
             crs =   std.get(course)
             return  crs.get(assessment);
```
].rvl-num[3]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
### Context
### Computation
### Quizzes
#### Quiz #1
]
.botbody.oldsections[
### Quizzes
#### Quiz #1

.col45[
.card.bg-r[
##### Question
.content.tight[
Consider the class .X[`Box`] on the right.  .X[Which law is violated?]  Select ALL options that apply.
]
]
.card.bg-g[
##### Monad Law
.content.tight.fsize14[
1. .X[Left Identity]
.nol[
- &forall; `x`,`f`:
  - `M.of(`.X.hilite-y[`x`]`).fm(`.X.hilite-y[`x -> f(x)`]`)`
  - &equiv; .X.hilite-y[`f(x)`]
]
2. .X[Right Identity]
.nol[
- &forall; `m`: .X.hilite-y[`m`]`.fm(x -> M.of(x))`
  - &equiv; .X.hilite-y[`m`]
]
3. .X[Associative]
.nol[
- &forall; `m`,`f`,`g`:
  - `m.fm(x -> f(x)`.X.drdtxt.hilite-y[`)`]
  - .op0[`m`]`.fm(x -> g(x))`
  - &equiv;
  - `m.fm(x ->`
      - .op0[....]`f(x).fm(x -> g(x))`.X.drdtxt.hilite-y[`)`]
]
]
]
]
.col55[
.font14[
```java[lite=12]
class Box {
  private int v;
  private Box(int v) {
    this.v = v;
  }
  public static Box of(int v) {
    return new Box(v);
  }
  public Box fm(Transformer
      <Integer, Box> fn) {
    Box val = fn.transform(this.v);
    int res = Math.max(this.v, val.v);
    return Box.of(res);
  }
}
```
]
]

.mrq.cmnt-s[
1. .quiz-choice[.X[left identity]] .quiz-ans[1] .quiz-hint[YES: only this]
1. .quiz-choice[.X[right identity]] .quiz-ans[0] .quiz-hint[NO: no violation]
1. .quiz-choice[.X[associative]] .quiz-ans[0] .quiz-hint[NO: no violation]
1. .quiz-choice[None of the above] .quiz-ans[0] .quiz-hint[NO: there is a violation]

.quizzes-time[120]
]
]

---

# Monad

.topsub.subsections[
### Motivation
### Attempts
### Monad
### Context
### Computation
### Quizzes
#### Quiz #1
#### Quiz #2
]
.botbody.oldsections[
### Quizzes
#### Quiz #2

.col45[
.card.bg-r[
##### Question
.content.tight[
Consider the class .X[`Box`] on the right.  .X[Which law is violated?]  Select ALL options that apply.
]
]
.card.bg-g[
##### Monad Law
.content.tight.fsize14[
1. .X[Left Identity]
.nol[
- &forall; `x`,`f`:
  - `M.of(`.X.hilite-y[`x`]`).fm(`.X.hilite-y[`x -> f(x)`]`)`
  - &equiv; .X.hilite-y[`f(x)`]
]
2. .X[Right Identity]
.nol[
- &forall; `m`: .X.hilite-y[`m`]`.fm(x -> M.of(x))`
  - &equiv; .X.hilite-y[`m`]
]
3. .X[Associative]
.nol[
- &forall; `m`,`f`,`g`:
  - `m.fm(x -> f(x)`.X.drdtxt.hilite-y[`)`]
  - .op0[`m`]`.fm(x -> g(x))`
  - &equiv;
  - `m.fm(x ->`
      - .op0[....]`f(x).fm(x -> g(x))`.X.drdtxt.hilite-y[`)`]
]
]
]
]
.col55[
.font14[
```java[lite=12]
class Box {
  private int v;
  private Box(int v) {
    this.v = v;
  }
  public static Box of(int v) {
    return new Box(v);
  }
  public Box fm(Transformer
      <Integer, Box> fn) {
    Box val = fn.transform(this.v);
    int res = this.v;
    return Box.of(res);
  }
}
```
]
]

.mrq.cmnt-s[
1. .quiz-choice[.X[left identity]] .quiz-ans[1] .quiz-hint[YES: only this]
1. .quiz-choice[.X[right identity]] .quiz-ans[0] .quiz-hint[NO: no violation]
1. .quiz-choice[.X[associative]] .quiz-ans[0] .quiz-hint[NO: no violation]
1. .quiz-choice[None of the above] .quiz-ans[0] .quiz-hint[NO: there is a violation]

.quizzes-time[120]
]
]

---

name: Break
class: middle, break

# Break

<br>

## <i class="fa-regular fa-clock break-icon"></i>

---
name: Concurrent_&_Parallel
class: sections

# Concurrent & Parallel

.topsub.subsections[
### Motivation
#### Sequential
]
.botbody.oldsections[
### Motivation
#### Sequential

.col100[
.img85.center[![Node](img/10-Parallel01.png)]
]

.col100.abs.bot2[
.col100[
```java
v1 = init;
v2 = f1(v1);          // 10s
v3 = f2(v1);          // 10s
v4 = g1(v2);          // 10s
v5 = g3(v3);          // 10s
v6 = h3(v5);          // 10s
v7 = fn(v4, v3, v6);  // 10s
v8 = gn(v7)           // 10s
```
]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
#### Sequential
#### Concurrent
]
.botbody.oldsections[
### Motivation
#### Concurrent

.col100[
.img85.center[![Node](img/10-Parallel02.png)]
]

.col100.abs.bot2[
.col50[
```java[copy=nones]
v1 = init;
v2 = f1(v1);  // 10s
​              // 10s (idle)
v4 = g1(v2);  // 10s
​              // 10s (idle)
​              // 10s (idle)
v7 = fn(v4, v3, v6); // 10s
v8 = gn(v7)          // 10s
```
]
.col50[
```java[copy=nones]
​
​              // 10s (idle)
v3 = f2(v1);  // 10s
​              // 10s (idle)
v5 = g3(v3);  // 10s
v6 = h3(v5);  // 10s
​
​
```
]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
#### Sequential
#### Concurrent
#### Parallel
]
.botbody.oldsections[
### Motivation
#### Parallel

.col100[
.img85.center[![Node](img/10-Parallel03.png)]
]

.col100.abs.bot2[
.col50[
```java[copy=nones]
v1 = init;
v2 = f1(v1);  // 10s
v4 = g1(v2);  // 10s
​              // 10s (idle)
v7 = fn(v4, v3, v6); // 10s
v8 = gn(v7)          // 10s
```
]
.col50[
```java[copy=nones]
​
v3 = f2(v1);  // 10s
v5 = g3(v3);  // 10s
v6 = h3(v5);  // 10s
​
​
```
]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
]
.botbody.oldsections[
### IntStream
#### Parallelizing Computation

.col100[
.font14[
```java
boolean isPrime(int n) {
  return IntStream.range(2, (int)Math.sqrt(n) + 1)
                  .noneMatch(x -> n % x == 0);
}
```
]
]

.col100.unrvl-tgl[
.font14[
```java
IntStream.range(2_030_000, 2_040_000)
​
         .filter(x -> isPrime(x))
         .forEach(System.out::println);
```
]
]
.col100.rvl-tgl[
.font14[
```java[lite=2]
IntStream.range(2_030_000, 2_040_000)
         .parallel()
         .filter(x -> isPrime(x))
         .forEach(System.out::println);
```
]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
]
.botbody.oldsections[
### Considerations

.col100[
#### No Interference

.font14[
```java
List<String> list = new ArrayList<>(List.of("Luke", "Leia", "Han"));
list.stream().peek(name -> { if (name.equals("Han")) {
                                list.add("Chewie");
                              } })
             .forEach(x -> {});  
```
]
]

.col100[.op0[.]]

.col100.rvl[
#### No Side Effect

.font14[
```java
List<Integer> list = new ArrayList<>(
  Arrays.asList(1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29)
);

List<Integer> result = new ArrayList<>();
list.parallelStream().filter(x -> isPrime(x)).forEach(System.out::println);
list.parallelStream().filter(x -> isPrime(x)).forEach(x -> result.add(x));
list.parallelStream().filter(x -> isPrime(x)).toList();
```
]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
#### API
]
.botbody.oldsections[
### Reduce
#### API

.col100[
<iframe class="inline-frame" id="ifrm1" src="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)" width="100%" height="700px" frameborder="0" ></iframe>
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
]
.botbody.oldsections[
### Reduce
#### Sequential

.col100[
.font14[
```java
T reduce(T e, BinaryOperator<T> f)
```
]
]

.col100[.op0[.]]

.col100[
.img80[![Reduce](img/10-Reduce01.png)]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
]
.botbody.oldsections[
### Reduce
#### Parallel

.col100[
.font14[
```java
T reduce(T e, BinaryOperator<T> f)
```
]
]

.col100[.op0[.]]

.col100[
.img80[![Reduce](img/10-Reduce02.png)]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
]
.botbody.oldsections[
### Reduce
#### Parallel

.col100[
.font14[
```java
<U> U reduce(U e, BiFunction<U,? super T,U> f, BinaryOperator<U> g)
```
]
]

.col100[.op0[.]]

.col100[
.img80[![Reduce](img/10-Reduce03.png)]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
#### API
#### Sequential
#### Parallel
#### Properties
]
.botbody.oldsections[
### Reduce
#### Properties

.col100[
.font14[
```java
<U> U reduce(U e, BiFunction<U,? super T,U> f, BinaryOperator<U> g)
```
]
]

.col100[.op0[.]]

.col100[
.card.bg-b[
##### Sufficient Condition
.content.tight[
If the following properties are satisfied, then the call to .X[`reduce`] is .X[parallelizable].  In other words, the .U[sequential] and .U[parallel] execution always produce the same result.
]
]
]

.col100[.op0[.]]

.col100[
.atbl.blhead.font14[
| Property | Description |
|---|---|
| `e` is .X[identity] | `g(e, x)` &equiv; `x`<br>.op0[.....].U[or] `f(e, x)` &equiv; `x` .note12[(for 2 param variants)] |
| `f` and `g` are .X[pure functions] | `f` and `g` has no side-effect and deterministic |
| `f` and `g` are .X[associative] | `g(g(x, y), z)` &equiv; `g(x, g(y, z))`<br>.op0[.....].U[or] `f(f(x, y), z)` &equiv; `f(x, f(y, z))` .note12[(for 2 param variants)] |
| `f` and `g` are [.U[compatible]](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#reduce%28java.lang.Object,java.util.function.BiFunction,java.util.function.BinaryOperator%29) | `g(x, f(e, y))` &equiv; `f(x, y)` |
]
]

.col100[.op0[.]]

.col100.rvl[
.card.bg-r[
##### Not Necessary
.content.tight[
The condition is not necessary.  In particular, we may have .X.drdtxt[non-associative] `f` and `g` but the reduction is still parallelizable.
]
]
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
### Examples
#### Example #1
]
.botbody.oldsections[
### Examples
#### Example #1

.col100[
##### Sum

.font14[
```java
List<Integer> list = new ArrayList<Integer>();
for (int i=1; i<=10000; i++) {
  list.add(i);
}
list.stream().parallel().reduce(0, (acc, elem) -> acc + elem);  
```
]
]

.col100.rvl-step[
.card.bg-y[
##### Information
.content.tight.nol[
- .X[`e`:] `0`
- .X[`f`:] `(acc, elem) -> acc + elem`
].rvl-num[1]
]
]

.col100[.op0[.]]

.col100.rvl-step[
##### Identity

<textarea class="text-editor editor20 wt95" style="height:50px">
</textarea>

##### Associative

<textarea class="text-editor editor20 wt95" style="height:50px">
</textarea>
.rvl-num[1]
]
]
.abs.top2.rt0.wt45[
.atbl.blhead.font12[
| Property | Description |
|---|---|
| .X[identity] | `f(e, x)` &equiv; `x` |
| .X[associative] | `f(f(x, y), z)` &equiv; `f(x, f(y, z))` |
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Motivation
### IntStream
### Considerations
### Reduce
### Examples
#### Example #1
#### Example #2
]
.botbody.oldsections[
### Examples
#### Example #2

.col100[
##### Length

.font14[
```java
List<String> list = List.of("CS", "2030", "S");
list.stream().parallel().reduce(0,
    (acc, elem) -> acc + elem.length(),
    (acc1, acc2) -> acc1 + acc2);
```  
]
]

.col100.rvl-step[
.card.bg-y[
##### Information
.content.tight.nol[
- .X[`e`:] `0`
- .X[`f`:] `(acc, elem) -> acc + elem.length()`
- .X[`g`:] `(acc1, acc2) -> acc1 + acc2`
].rvl-num[1]
]
]

.col100[.op0[.]]

.col100.rvl-step[
##### Identity

<textarea class="text-editor editor20 wt95" style="height:50px">
</textarea>

##### Associative

<textarea class="text-editor editor20 wt95" style="height:50px">
</textarea>

##### Compatible

<textarea class="text-editor editor20 wt95" style="height:50px">
</textarea>
.rvl-num[1]
]
]
.abs.top2.rt0.wt45[
.atbl.blhead.font12[
| Property | Description |
|---|---|
| .X[identity] | `g(e, x)` &equiv; `x` |
| .X[associative] | `g(g(x, y), z)` &equiv; `g(x, g(y, z))` |
| .X[compatible] | `g(x, f(e, y))` &equiv; `f(x, y)` |
]
]

---

# Concurrent & Parallel

.topsub.subsections[
### Preliminary
### IntStream
### Considerations
### Reduce
### Examples
### Timing
]
.botbody.oldsections[
### Timing
#### Code

.col100.unrvl-step[
.font14[
```java
boolean isPrime(int n) {
  return IntStream.range(2, (int)Math.sqrt(n) + 1)
      .noneMatch(x -> n % x == 0);
}
```
].unrvl-num[2]
]
.col100.rvl-step[
.font14[
```java[lite=2]
boolean isPrime(int n) {
  return IntStream.range(2, (int)Math.sqrt(n) + 1).parallel()
      .noneMatch(x -> n % x == 0);
}
```
].rvl-num[2]
]
.col100.unrvl-step[
.font14[
```java[lite=3,7]
class Timing {
  public static void main(String[] args) {
    Instant start = Instant.now();
    long count = IntStream.range(2_000_000, 3_000_000)
        .filter(x -> isPrime(x))
        .count();
    Instant stop = Instant.now();
    long duration = Duration.between(start, stop).toMillis();
    System.out.println("count: " + count);
    System.out.println("time : " + duration + " ms");
  }
}
```
].unrvl-num[1]
]
]
.col100.rvl-step[
.font14[
```java[lite=5]
class Timing {
  public static void main(String[] args) {
    Instant start = Instant.now();
    long count = IntStream.range(2_000_000, 3_000_000)
        .filter(x -> isPrime(x)).parallel()
        .count();
    Instant stop = Instant.now();
    long duration = Duration.between(start, stop).toMillis();
    System.out.println("count: " + count);
    System.out.println("time : " + duration + " ms");
  }
}
```
].rvl-num[1]
]

---

class: middle, end, fadein

.eol[`jshell> /exit`]


.eol[`| Goodbye`]