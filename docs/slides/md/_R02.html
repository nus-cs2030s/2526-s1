layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga Sidi Prabawa</p></div>

---

name: Introduction
class: bottom, titles

# CS2030S
## Programming Methodology II
### R02

---

name: Question_1
class: middle, sections

# Question 1

---

# Question 1

.ft10.subsections[
### Specification
]
.ft88.oldsection[
### Specification
#### In English

.col55[
.card.bg-b[
##### Rectangle
.content.tight[
If
.nol[
- the most recent call to `setWidth`.op0[`.`] is
    - `r.setWidth`.op0[`.`]`(w)`
- the most recent call to `setHeight` is
    - `r.setHeight(h)`
]
then `r.getArea()` must return `w * h`.
]
]
]

.col45[
.card.bg-b[
##### Square
.content.tight[
A square must have all four sides to be of the same length.
]
]
]

.col100[]

.col55[
```java[copy=nones]
Rectangle r = new Rectangle(5, 5)
r.setHeight(5)
r.setWidth(9)
r.getArea() // 45.0
```
]
.col45[
```java[copy=nones]
Square s = new Square(5, 5)
r.setWidth(9)
r.getArea() // 81.0
```
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
]
.ft88.oldsection[
### Code

.col60[
.font18[
```java[copy=nones]
public class Rectangle {
  private double width;
  private double height;

  public Rectangle(double width, double height) {
    this.width = width;
    this.height = height;
  }

  public double getArea() {
    return this.width * this.height;
  }

  @Override
  public String toString() {
    return "Height: " + this.height
        + " Width: " + this.width;
  }
}
```
]
]
.col40[
#### Sample Run
.font18[
```jshell[copy=nones]
jshell> new Square(5)
$.. ==> Height: 5 Width: 5
jshell> new Square(5).getArea()
$.. ==> 25
```
]

.card.bg-r[
##### Question
.content.tight[
Can you identify the following

- the fields of `Square`?
- the methods of `Square`?
.nol[
- the method signature?
]
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
]
.ft88.oldsection[
### Code

.col60[
.font18[
```java[copy=nones]
public class Rectangle {
  private double width;
  private double height;

  public Rectangle(double width, double height) {
    this.width = width;
    this.height = height;
  }

  public double getArea() {
    return this.width * this.height;
  }

  @Override
  public String toString() {
    return "Height: " + this.height
        + " Width: " + this.width;
  }
}
```
]
]
.col40[
#### Sample Run
.font18[
```jshell[copy=nones]
jshell> new Square(5)
$.. ==> Height: 5 Width: 5
jshell> new Square(5).getArea()
$.. ==> 25
```
]

.card.bg-g[
##### Fields
.content.tight.font20[
- `width`
- `height`
]
]

.card.bg-g[
##### Methods
.content.tight.font20[
- `Rectangle(double, double)`
- `double getArea()`
- `String toString()`
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
]
.ft88.oldsection[
### Code

.col60[
.font18[
```java[copy=nones]
public class Rectangle {
  private double width;
  private double height;

  public Rectangle(double width, double height) {
    this.width = width;
    this.height = height;
  }

  public double getArea() {
    return this.width * this.height;
  }

  @Override
  public String toString() {
    return "Height: " + this.height
        + " Width: " + this.width;
  }
}
```
]
]
.col40[
#### Sample Run
.font18[
```jshell[copy=nones]
jshell> new Square(5)
$.. ==> Height: 5 Width: 5
jshell> new Square(5).getArea()
$.. ==> 25
```
]

.card.bg-b[
##### Minimum Code
.content.tight[
.font16[
```java[copy=nones]
public class Square
    extends Rectangle {
  public Square(double length) {
    super(length, length);
  }
}
```
]
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
#### Rectangle
]
.ft88.oldsection[
### Modification
#### Rectangle

.col60[
.font18[
```java[copy=nones]
public class Rectangle {
  private double width;
  private double height;

  // : code omitted

  public void setHeight(double height) {
    this.height = height;
  }

  public void setWidth(double width) {
    this.width = width;
  }
}
```
]
]
.col40[


.card.bg-r[
##### Question
.content.tight[
Any failing test cases?<br>
What does it signify?
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
#### Rectangle
]
.ft88.oldsection[
### Modification
#### Rectangle

.col60[
.font18[
```java[copy=nones]
public class Rectangle {
  private double width;
  private double height;

  // : code omitted

  public void setHeight(double height) {
    this.height = height;
  }

  public void setWidth(double width) {
    this.width = width;
  }
}
```
]
]

.col40[
.card.bg-g[
##### Violation
.content.tight[
Although the change is in `Rectangle`, the class `Square` that extends from `Rectangle` does not satisfy the property of Square.cite[] as specified earlier.

<br>

.font16[
```java[copy=nones]
Square s = new Square(5);
s.setHeight(7);
s.getArea(); // 35: not square!
```
]
]
]
]
]
.footnote[Width and height must be equal.]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
#### Rectangle
]
.ft88.oldsection[
### Modification
#### Rectangle

.col60[
.font18[
```java[copy=nones]
public class Rectangle {
  private double width;
  private double height;

  // : code omitted

  public void setHeight(double height) {
    this.height = height;
  }
  
  public void setWidth(double width) {
    this.width = width;
  }
}
```
]
]

.col40[
.card.bg-b[
##### LSP Violation?
.content.tight[
LSP is not violated as the property of the superclass Rectangle.cite[] is not violated by the `Square`.
But the problem is the `Square` is not satisfying the property of a Square.

<br>

.nol[
- Width and height must be equal.
]
]
]
]
]
.footnote[Width and heigth can be **independently** modified.]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
#### Rectangle
#### Square
]
.ft88.oldsection[
### Modification
#### Square

.col60[
.font18[
```java[copy=nones]
public class Square {
  // : code omitted

  @Override
  public void setHeight(double height) {
    super.setHeight(height);
    super.setWidth(height);
  }

  @Override
  public void setWidth(double width) {
    super.setHeight(width);
    super.setWidth(width);
  }
}
```
]
]
.col40[
.card.bg-r[
##### Question
.content.tight[
Any failing test cases?<br>
What does it signify?
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
#### Rectangle
#### Square
]
.ft88.oldsection[
### Modification
#### Square

.col60[
.font18[
```java[copy=nones]
public class Square {
  // : code omitted

  @Override
  public void setHeight(double height) {
    super.setHeight(height);
    super.setWidth(height);
  }

  @Override
  public void setWidth(double width) {
    super.setHeight(width);
    super.setWidth(width);
  }
}
```
]
]

.col40[
.card.bg-g[
##### Violation
.content.tight[
If we create a `Rectangle` with run-time type of `Square`, we will see that it violates the property of the Rectangle.

<br>

.font16[
```java[copy=nones]
Rectangle r = new Square(5);
r.setHeight(7);
r.getArea(); // 49: not rectangle!
```
]
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
#### Rectangle
#### Square
]
.ft88.oldsection[
### Modification
#### Square

.col60[
.font18[
```java[copy=nones]
public class Square {
  // : code omitted

  @Override
  public void setHeight(double height) {
    super.setHeight(height);
    super.setWidth(height);
  }

  @Override
  public void setWidth(double width) {
    super.setHeight(width);
    super.setWidth(width);
  }
}
```
]
]

.col40[
.card.bg-b[
##### LSP Violation?
.content.tight[
In this case, LSP is indeed violated because `Rectangle` satisfies the property of Rectangle but `Square` as a subclass of Rectangle does not satisfy the property of Rectangle.

<br>

.nol[
- Width and heigth can be **independently** modified.
]
]
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
### LSP
#### Formally
]
.ft88.oldsection[
### LSP
#### Formally

.col100[
.card.bg-g[
##### Formal LSP Statement
.content.tight[
.font40.center[**(`S` <: `T` &wedge; &varphi;(`T`)) &rarr; &varphi;(`S`)**]

<br>

LSP is violated if the statement above evaluates to False.
]
]
]

##### Truth Table

.col50[
.atbl.blhead[
| x | y | x &wedge; y |
|---|---|---|
| True | True | True |
| True | False | False |
| False | True | False |
| False | False | False |
]
]

.col50[
.atbl.blhead[
| x | y | x &rarr; y |
|---|---|---|
| True | True | True |
| True | False | False |
| False | True | True |
| False | False | True |
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
### LSP
#### Formally
]
.ft88.oldsection[
### LSP
#### Formally

.col100[
.card.bg-g[
##### Formal LSP Statement
.content.tight[
.font40.center[**(`S` <: `T` &wedge; &varphi;(`T`)) &rarr; &varphi;(`S`)**]

<br>

LSP is violated if the statement above evaluates to False.
]
]
]

##### Intuition

.card.bg-b[
##### Truth Preservation
.content.tight[
The intuition behind why **x &rarr; y** is False only when **x** is True and **y** is False is that we want to preserve the truth.
What we do not want is to be able to conclude something that is False from a premise that is True.

<br>

However, if the original premise is already False, then we can conclude anything.
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
### LSP
#### Formally
#### Q1B
]
.ft88.oldsection[
### LSP
#### Q1B

.col100[
.card.bg-g[
##### Formal LSP Statement
.content.tight[
.font40.center[**(`S` <: `T` &wedge; &varphi;(`T`)) &rarr; &varphi;(`S`)**]

<br>

For Q1B, the statement is True because "`S` <: `T` &wedge; &varphi;(`T`)" is False .note20[(shown below)].
]
]
]

.col50[
##### Given

- Let `S` = `Square`.
- Let `T` = `Rectangle`.
- Let &varphi;(`C`) be the statement that property of Square.cite[] is satisfied by class `C`.
]

.col50[
##### Analysis
.col30[
- `S` <: `T`<br><br>
- &varphi;(`T`)<br><br><br>
- `S` <: `T` &wedge; &varphi;(`T`)
]
.col70.nol[
- Satisfied as `Square` <: `Rectangle`.
- Not satisfied as width and height of `Rectangle` can be different.
- **False** so "(S <: T ∧ ϕ(T)) → ϕ(S)" is True by the truth table.
]
]
]
.footnote[Width and height must be equal.]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
### LSP
#### Formally
#### Q1B
]
.ft88.oldsection[
### LSP
#### Q1B

.col35[
##### Given

- Let `S` = `Square`.
- Let `T` = `Rectangle`.
- Let &varphi;(`C`) be a statement
.nol[
- Class `C` is designed such that its width and height must always be equal.
]
]

.col65[
##### Analysis

1. `S` <: `T` is satisfied as `Square` <: `Rectangle`.
2. &varphi;(`T`) is not satisfied as `T` is `Rectangle` and the width and height of `Rectangle` can be different .note20[(see implementation)].
3. `S` <: `T` &wedge; &varphi;(`T`) is False because &varphi;(`T`) is False from (2).
4. `S` <: `T` &wedge; &varphi;(`T`) &rarr; &varphi;(`S`) is True because `S` <: `T` &wedge; &varphi;(`T`) is False from (3).

.nol[
- ∴ LSP is not violated as `S` <: `T` &wedge; &varphi;(`T`) &rarr; &varphi;(`S`) is True.
]
]
]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
### LSP
#### Formally
#### Q1B
#### Q1C
]
.ft88.oldsection[
### LSP
#### Q1C

.col100[
.card.bg-g[
##### Formal LSP Statement
.content.tight[
.font40.center[**(`S` <: `T` &wedge; &varphi;(`T`)) &rarr; &varphi;(`S`)**]

<br>

For Q1C, the statement is True because "`S` <: `T` &wedge; &varphi;(`T`)" is True but "&varphi;(`S`)" is False.
]
]
]

.col50[
##### Given

- Let `S` = `Square`.
- Let `T` = `Rectangle`.
- Let &varphi;(`C`) be the statement that property of Rectangle.cite[] is satisfied by class `C`.
]

.col50[
##### Analysis
.col30[
- `S` <: `T`<br><br>
- &varphi;(`T`)<br><br><br>
- &varphi;(`S`)
]
.col70.nol[
- Satisfied as `Square` <: `Rectangle`
- Satisfied as width and height of `Rectangle` can be different.
- Not satisfied as width and height are always equal.
]
]
]
.footnote.font20[Width and heigth can be **independently** modified.]

---

# Question 1

.ft10.subsections[
### Specification
### Code
### Modification
### LSP
#### Formally
#### Q1B
#### Q1C
]
.ft88.oldsection[
### LSP
#### Q1C

.col35[
##### Given

- Let `S` = `Square`.
- Let `T` = `Rectangle`.
- Let &varphi;(`C`) be a statement
.nol[
- Class `C` is designed such that its width and height can be **independently** modified.
]
]

.col65[
##### Analysis

1. `S` <: `T` is satisfied as `Square` <: `Rectangle`
2. &varphi;(`T`) is satisfied as `T` is `Rectangle` and the width and height of `Rectangle` can be independently modified .note20[(see implementation)].
3. `S` <: `T` &wedge; &varphi;(`T`) is True because `S` <: `T` is True from (1) and &varphi;(`T`) is True from (2).
4. &varphi;(`S`) is not satisfied because `S` is `Square` and the width and height of `Square` must be the same .note20[(see implementation)].
5. `S` <: `T` &wedge; &varphi;(`T`) &rarr; &varphi;(`S`) is False because `S` <: `T` &wedge; &varphi;(`T`) is True but &varphi;(`S`) is False.


.nol[
- ∴ LSP is violated as `S` <: `T` &wedge; &varphi;(`T`) &rarr; &varphi;(`S`) is False.
]
]
]

---

name: Question_2
class: middle, sections

# Question 2

---

# Question 2

.ft10.subsections[
### Type Casting
#### Compile-Time
]
.ft88.oldsection[
### Type Casting

.font18[
```java[copy=nones]
a = (C) b;
```
]

#### Compile-Time

1. Find CTT(`b`).
2. Is there a ".uline[_possibility_]" of a .hilite-y[type `T` <: CTT(`b`).cite[]] to be converted to `C`?<br>.note20[Also consider potential classes to be added in the future.]
.nol[
- If yes, continue to step 3.
- If no, compilation error.
]
3. Find CTT(`a`).
4. Is `C` <: CTT(`a`)?
.nol[
- If yes, compile + add run-time check.
- If no, compilation error.
]
]
.abs.bot10.rt2.wt40.ft[
.card.bg-y[
##### Note
.content.tight[
- **Step 1 - 2:** Check Type Cast.
- **Step 3 - 4:** Check Assignment.
]
]
]
.footnote[In the online notes, this is simply RTT(`b`) because by definition RTT(`b`) <: CTT(`b`).]

---

# Question 2

.ft10.subsections[
### Type Casting
#### Compile-Time
#### Run-Time
]
.ft88.oldsection[
### Type Casting

.font18[
```java[copy=nones]
a = (C) b;
```
]

#### Run-Time

.col50[
1. Find RTT(`b`).
2. Is RTT(`b`) <: `C`?
.nol[
- If yes, OK.
- If no, run-time error.
]
]

.col50[
```java[copy=nones]
if (!(b instanceof C)) {
  throw ClassCastException(...);
}
```
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
]
.ft88.oldsection[
### Type Check

.col50[
#### Code
.font18[
```java[copy=nones]
interface Shape {
  double getArea();
}
```
```java[copy=nones]
interface Printable {
  void print();
}
```
]
]
.col50[
#### Usage
.font18[
```java[copy=nones]
Circle c = new Circle(...);
Shape s = c;
Printable p = c;
```
]

.col50[
##### Shape

.font18[
```java[copy=nones]
s.print();
s.getArea();
```
]
]
.col50[
##### Printable

.font18[
```java[copy=nones]
p.print();
p.getArea();
```
]
]

.col100[
.card.bg-r[
##### Question
.content.tight[
Which methods are **known** to be available at _compile-time_?
]
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
]
.ft88.oldsection[
### Type Check

.col50[
#### Code
.font18[
```java[copy=nones]
interface Shape {
  double getArea();
}
```
```java[copy=nones]
interface Printable {
  void print();
}
```
]
]
.col50[
#### Usage
.font18[
```java[copy=nones]
Circle c = new Circle(...);
Shape s = c;
Printable p = c;
```
]

.col50[
##### Shape

.font18[
```java[copy=nones|emph=2]
s.print();
s.getArea();
```
]
]
.col50[
##### Printable

.font18[
```java[copy=nones|emph=1]
p.print();
p.getArea();
```
]
]

.col100[
.card.bg-b[
##### Comment
.content.tight[
Only look at the **compile-time type** to see which method can be safely invoked.
Since CTT(`s`) is `Shape`, it only has `getArea()`.cite[].
]
]
]
]
]
.footnote[An exception is the methods in `Object` which are always available.]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
]
.ft88.oldsection[
### Abstract Class
#### Code

.col50[
.font18[
```java[copy=nones]
abstract class Shape {
  public abstract double getArea();
}
```
```java[copy=nones]
abstract class Printable {
  public abstract void print();
}
```
.op0[
```java[copy=nones]
interface PrintableShape
  extends Shape, Printable { }
```
]
]
.card.bg-y[
##### Circle
.content.tight[
.nol[
- `Circle` <: `Shape`
- `Circle` <: `Printable`
]
]
]
]
.col50[
.card.bg-r[
##### Question
.content.tight[
Can we make `Shape` and `Printable` abstract class?
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
]
.ft88.oldsection[
### Abstract Class
#### Code

.col50[
.font18[
```java[copy=nones]
abstract class Shape {
  public abstract double getArea();
}
```
```java[copy=nones]
abstract class Printable {
  public abstract void print();
}
```
.op0[
```java[copy=nones]
interface PrintableShape
  extends Shape, Printable { }
```
]
]
.card.bg-y[
##### Circle
.content.tight[
.nol[
- `Circle` <: `Shape`
- `Circle` <: `Printable`
]
]
]
]
.col50[
.card.bg-g[
##### Comment
.content.tight[
1. Let `Shape` and `Printable` be abstract classes.
2. We want `Circle` <: `Shape` and `Circle` <: `Printable`.
3. `Circle` is a class and a class can only extend another class.
4. Since `Shape` </: `Printable` and `Printable` </: `Shape`, we need `Circle` to extends both `Shape` and `Printable`.
5. This contradicts (3) and we will have a compilation error.
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
]
.ft88.oldsection[
### Multiple
#### Code

.col50[
.font18[
```java[copy=nones]
interface Shape {
  double getArea();
}
```
```java[copy=nones]
interface Printable {
  void print();
}
```
```java[copy=nones]
interface PrintableShape
    extends Shape, Printable { }
```
]
.card.bg-y[
##### Circle
.content.tight[
.nol[
- `Circle` <: `Shape`
- `Circle` <: `Printable`
]
]
]
]
.col50[
.card.bg-r[
##### Question
.content.tight[
Can we define another interface called `PrintableShape`?
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
]
.ft88.oldsection[
### Multiple
#### Code

.col50[
.font18[
```java[copy=nones]
interface Shape {
  double getArea();
}
```
```java[copy=nones]
interface Printable {
  void print();
}
```
```java[copy=nones]
interface PrintableShape
    extends Shape, Printable { }
```
]
.card.bg-y[
##### Circle
.content.tight[
.nol[
- `Circle` <: `Shape`
- `Circle` <: `Printable`
]
]
]
]
.col50[
.card.bg-g[
##### Comment
.content.tight[
1. Let `Shape` and `Printable` be interfaces.
2. We want `PrintableShape` <: `Shape` and `PrintableShape` <: `Printable`.
3. `PrintableShape` is an interface and an interface can extend 0 or more interfaces.
4. Hence, this is allowed.
5. `Circle` can simply implements `PrintableShape`.
.font18.nol[
- **By Transitivity**
    - `Circle` **<:** `PrintableShape` **<:** `Shape`
    - `Circle` **<:** `PrintableShape` **<:** `Printable`
]
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
]
.ft88.oldsection[
### Diamond
#### Case #1

.col38[
![Diagram](https://nus-cs2030s.github.io/2324-s1/figures/ClassDiagram18.png)
]
.col62[
.card.bg-r[
##### Question
.content.tight[
Assume we can instantiate the following.

```java[copy=nones]
U u = new U(...);
u.f();
```

Which method is invoked?
1. `T1::f()`?
1. `T2::f()`?<br><br>
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
]
.ft88.oldsection[
### Diamond
#### Case #1

.col38[
![Diagram](https://nus-cs2030s.github.io/2324-s1/figures/ClassDiagram18.png)
]
.col62[
.card.bg-g[
##### Comment
.content.tight[
Ambiguous, with the error being `U` cannot inherit from both `T1` and `T2`.

<br>

But assuming it can, then we do not know which method to invoke.
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
#### Case #2
]
.ft88.oldsection[
### Diamond
#### Case #2

.col38[
![Diagram](https://nus-cs2030s.github.io/2324-s1/figures/ClassDiagram19.png)
]
.col62[
.card.bg-r[
##### Question
.content.tight[
Assume we can instantiate the following.

```java[copy=nones]
U u = new U(...);
u.f();
```

Which method is invoked?
1. `T1::f()`?
1. `T2::f()`?<br><br>
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
#### Case #2
]
.ft88.oldsection[
### Diamond
#### Case #2

.col38[
![Diagram](https://nus-cs2030s.github.io/2324-s1/figures/ClassDiagram19.png)
]
.col62[
.card.bg-g[
##### Comment
.content.tight[
Still ambiguous, but the error is caused somewhere else.

<br>

- `U` inherits `void f()` from `T1` and `T2`.
- `U` has no implementation of `void f()`.
- `void f()` is abstract method in `U`.
- `U` has to be an abstract class.
- `U u = new U(...)` will give rise to compilation error as it tries to instantiate abstract class.
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
#### Case #2
#### Case #3
]
.ft88.oldsection[
### Diamond
#### Case #3

.col38[
![Diagram](https://nus-cs2030s.github.io/2324-s1/figures/ClassDiagram20.png)
]
.col62[
.card.bg-r[
##### Question
.content.tight[
Assume we can instantiate the following.

```java[copy=nones]
U u = new U(...);
u.f();
```

Which method is invoked?
1. `T1::f()`?
1. `T2::f()`?
1. `U::f()`?
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
#### Case #2
#### Case #3
]
.ft88.oldsection[
### Diamond
#### Case #3

.col38[
![Diagram](https://nus-cs2030s.github.io/2324-s1/figures/ClassDiagram20.png)
]
.col62[
.card.bg-g[
##### Comment
.content.tight[
No issue here, `U::f()` is invoked.
We can make the reasoning more general by considering `V` <: `U`.

<br>

- `V` is no longer abstract and can be instantiated `U u = new V(...)`.
- `V` either implements `void f()` **OR** it has a superclass `W` such that `V` <: `W` <: `U` and `W` implements `void f()`.
- At run-time, we search for implementation starting from RTT(`u`) which is `V`.
- It will come across either `V::f()` or `W::f()` as the implementation.
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
#### Case #2
#### Case #3
#### Default
]
.ft88.oldsection[
### Diamond
#### Default

.col100[
.card.bg-b[
##### Further Analysis
.content.tight[
The reasoning in the previous slide relies on a hidden assumption:
.nol[
- **Interface has no concrete method.**
]

<br>

Unfortunately, this is not true in general in Java.
The reasoning breaks down if we allow `void f()` to be concrete in both `T1` and `T2`.
Then it need not be implemented in `U`.

<br>

In other words, `U` can be a concrete class that does not implement `void f()`.
This violation presents in Java 8 onwards with `default` method.
This kind of interface is called impure interface.

<br>

&rArr; .uline[_We do not talk about impure interface!_]
]
]
]
]

---

# Question 2

.ft10.subsections[
### Type Casting
### Type Check
### Abstract Class
### Multiple
### Diamond
#### Case #1
#### Case #2
#### Case #3
#### Default
]
.ft88.oldsection[
### Diamond
#### Default

.col50[
##### Types

```java[copy=nones]
interface I1 {
  default int f() { return 1; }
}
interface I2 {
  default int f() { return 2; }
}
```
```java[copy=nones]
class C1 implements I1, I2 {}
class C2 implements I1, I2 {
  public int f() { return 3; }
}
```
]

.col50[
##### Experiment

.card.bg-y[
##### Experiment #1
.content.tight[
1. Compile only `I1`, `I2`, and `C1`.
2. Add `main` method to invoke `int f()` by instantiating `C1`.
.nol[
- What do you observe?
]
]
]

.card.bg-y[
##### Experiment #2
.content.tight[
1. Compile only `I1`, `I2`, and `C2`.
2. Add `main` method to invoke `int f()` by instantiating `C2`.
.nol[
- What do you observe?
]
]
]
]
]

---

class: middle, end, fadein

.eol[`/exit`]


.eol[`| Goodbye`]